<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Automation Architects Playbook 2025</title>
    <style>
        body {
            font-family: Segoe UI, Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 40px;
            line-height: 1.7;
        }

        h1 {
            color: #1a1a2e;
            border-bottom: 3px solid #16213e;
            page-break-before: always;
        }

        h1:first-of-type {
            page-break-before: avoid;
        }

        h2 {
            color: #16213e;
            border-bottom: 1px solid #ddd;
        }

        h3 {
            color: #0f3460;
        }

        pre {
            background: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 16px;
            overflow-x: auto;
            font-family: Consolas, monospace;
            font-size: 13px;
        }

        code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: Consolas, monospace;
        }

        pre code {
            background: none;
            padding: 0;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        th {
            background: #16213e;
            color: white;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        blockquote {
            border-left: 4px solid #16213e;
            margin: 20px 0;
            padding: 10px 20px;
            background: #f9f9f9;
            font-style: italic;
        }

        @media print {
            pre {
                page-break-inside: avoid;
            }

            table {
                page-break-inside: avoid;
            }
        }

        /* Premium TOC Styles */
        .toc-container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 12px;
            padding: 2rem;
            margin: 3rem 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
        }

        .toc-title {
            font-size: 2rem;
            color: #1a1a2e;
            margin-bottom: 2rem;
            text-align: center;
            font-weight: 800;
            letter-spacing: -0.5px;
        }

        .toc-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.5rem;
        }

        .toc-part {
            background: #f8fafc;
            border-radius: 8px;
            padding: 1.25rem;
            border-left: 4px solid #0f3460;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .toc-part:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }

        .toc-part-title {
            font-size: 0.9rem;
            font-weight: 700;
            color: #0f3460;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .toc-chapter-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .toc-chapter-item {
            margin-bottom: 0.5rem;
        }

        .toc-chapter-link {
            text-decoration: none;
            color: #4a5568;
            font-size: 0.95rem;
            display: block;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .toc-chapter-link:hover {
            background: #edf2f7;
            color: #1a1a2e;
        }

        .toc-chapter-num {
            font-weight: 600;
            color: #718096;
            margin-right: 4px;
        }
    </style>
</head>

<body>
    <h1 id="the-automation-architects-playbook">The Automation Architect's Playbook</h1>
    <h2 id="a-comprehensive-guide-to-building-enterprise-grade-test-automation">A Comprehensive Guide to Building
        Enterprise-Grade Test Automation</h2>
    <h3 id="mastering-the-internals-from-browser-fundamentals-to-ai-powered-testing">Mastering the Internals: From
        Browser Fundamentals to AI-Powered Testing</h3>
    <hr />
    <p><em>This book represents years of practical experience solving real automation challenges. The tools, patterns,
            and approaches described have been deployed and refined through countless
            iterations.</em></p>
    <p style="text-align: center; margin: 2rem 0;">
        <img src="/book/images/cover.png" alt="The Automation Architect's Playbook Cover"
            style="max-width: 400px; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.3);" />
    </p>
    <hr />
    <h1 id="preface">Preface</h1>
    <h2 id="who-this-book-is-for">Who This Book Is For</h2>
    <p>This book is written for <strong>everyone who wants to truly understand test automation</strong>, not just
        copy-paste code that works "sometimes." Whether you're:</p>
    <ul>
        <li><strong>Junior QA Engineers</strong> starting your automation journey and wanting to understand <em>why</em>
            things work, not just <em>how</em></li>
        <li><strong>Mid-Level Automation Developers</strong> looking to level up and eliminate those mysterious flaky
            tests</li>
        <li><strong>Senior QA Engineers</strong> designing enterprise-scale frameworks</li>
        <li><strong>Automation Architects</strong> responsible for technical decisions that affect entire organizations
        </li>
        <li><strong>Developers</strong> who want to understand testing from the inside out</li>
        <li><strong>DevOps Engineers</strong> integrating test automation into CI/CD pipelines</li>
    </ul>
    <p>If you've ever wondered:
        - <em>"Why does my test pass locally but fail in CI?"</em>
        - <em>"What is the browser actually doing when I call <code>click()</code>?"</em>
        - <em>"Why can't Selenium find an element that's clearly on the page?"</em>
        - <em>"How do websites detect that I'm using automation?"</em></p>
    <p>This book will give you those answersâ€”and more.</p>
    <h2 id="what-makes-this-book-different">What Makes This Book Different</h2>
    <p>Unlike theoretical automation guides that show you the happy path, <strong>every chapter in this book is born
            from real production failures</strong>. These aren't academic exercisesâ€”they're battle-tested solutions that
        have been deployed in enterprise environments handling:</p>
    <ul>
        <li>1000+ automated tests running daily</li>
        <li>20+ microservices under test</li>
        <li>Multi-browser, multi-device coverage</li>
        <li>CI/CD integration with sub-10-minute feedback loops</li>
        <li>Applications protected by Cloudflare, bot detection, and modern security</li>
    </ul>
    <h3 id="the-philosophy-behind-this-work">The Philosophy Behind This Work</h3>
    <p><strong>"Automation should be invisible."</strong></p>
    <p>When automation works perfectly, nobody notices. When it fails, everyone suffers. The goal isn't to write
        testsâ€”it's to create a safety net that catches defects before they reach production while staying out of
        everyone's way.</p>
    <p>This book embraces three core principles:</p>
    <ol>
        <li><strong>Stability Over Speed</strong>: A reliable slow test beats a fast flaky one</li>
        <li><strong>Maintenance Minimization</strong>: Code that doesn't need fixing is the best code</li>
        <li><strong>Actionable Feedback</strong>: When things break, the cause should be obvious</li>
    </ol>
    <h3 id="mastering-the-internals">Mastering the Internals</h3>
    <p>This book isnâ€™t just about using toolsâ€”itâ€™s about understanding the mechanics behind them. We use a suite of
        specialized open-source tools as a lens to explore the deep internals of how modern automation actually
        works:</p>
    <table>
        <thead>
            <tr>
                <th>Tool</th>
                <th>Problem It Solves</th>
                <th>Category</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Waitless</strong></td>
                <td>Flaky tests from race conditions</td>
                <td>Stability</td>
            </tr>
            <tr>
                <td><strong>Project Vandal</strong></td>
                <td>Tests that pass but don't catch bugs</td>
                <td>Mutation Testing</td>
            </tr>
            <tr>
                <td><strong>Selenium Teleport</strong></td>
                <td>10+ seconds per login</td>
                <td>Authentication</td>
            </tr>
            <tr>
                <td><strong>SB Stealth Wrapper</strong></td>
                <td>Bot detection blocking tests</td>
                <td>Stealth</td>
            </tr>
            <tr>
                <td><strong>Lumos ShadowDOM</strong></td>
                <td>Elements hidden in Shadow DOM</td>
                <td>Modern Web</td>
            </tr>
            <tr>
                <td><strong>Visual Guard</strong></td>
                <td>Visual regressions missed by DOM tests</td>
                <td>Visual Testing</td>
            </tr>
            <tr>
                <td><strong>Visual Sonar</strong></td>
                <td>Automating remote desktops (no DOM)</td>
                <td>RPA</td>
            </tr>
            <tr>
                <td><strong>Selector Scout</strong></td>
                <td>Brittle, constantly-breaking selectors</td>
                <td>AI</td>
            </tr>
            <tr>
                <td><strong>Selenium Chatbot Test</strong></td>
                <td>Testing streaming AI interfaces</td>
                <td>GenAI</td>
            </tr>
            <tr>
                <td><strong>Pytest-MockLLM</strong></td>
                <td>Testing LLM features without API costs</td>
                <td>AI Testing</td>
            </tr>
            <tr>
                <td><strong>pytest-glow-report</strong></td>
                <td>Reports stakeholders can understand</td>
                <td>Reporting</td>
            </tr>
        </tbody>
    </table>
    <h2 id="how-to-use-this-book">How to Use This Book</h2>
    <h3 id="for-junior-developers-new-to-automation">For Junior Developers (New to Automation)</h3>
    <p>Start with <strong>Part I: Foundations</strong>. Don't skip Chapter 1 on browser internalsâ€”it will save you
        countless hours of debugging later. Every mysterious error you'll encounter has roots in concepts explained
        there.</p>
    <p><strong>Recommended path:</strong>
        1. Part I (Foundations) â†’ Part II (Visual Testing) â†’ Part III (Authentication)
        2. Then jump to topics as needed</p>
    <h3 id="for-mid-level-developers">For Mid-Level Developers</h3>
    <p>You can scan Part I quickly, but pay attention to the "Deep Dive" sections. Start with whatever chapter addresses
        your current pain point, then explore related topics.</p>
    <h3 id="for-seniorarchitect-level">For Senior/Architect Level</h3>
    <p>Use this as a reference guide. The implementation details in each tool chapter can be directly applied to your
        frameworks. Pay special attention to Part IX (Enterprise Patterns).</p>
    <h3 id="hands-on-learning">Hands-On Learning</h3>
    <p>Every chapter includes:
        - <strong>ğŸ’¡ Key Insight</strong> boxes highlighting critical concepts
        - <strong>ğŸ”§ Hands-On Exercise</strong> with step-by-step solutions
        - <strong>âš ï¸ Common Pitfalls</strong> that trip up even experienced developers
        - <strong>ğŸ” Deep Dive</strong> sections for those who want to understand internals
        - <strong>ğŸ“‹ Quick Reference</strong> summaries you can bookmark</p>
    <hr />
    <h1 id="prerequisites-setup-guide">Prerequisites &amp; Setup Guide</h1>
    <p>Before diving in, ensure you have:</p>
    <h3 id="required-software">Required Software</h3>
    <pre><code class="language-bash"># Python 3.10+ (recommended: 3.11 or 3.12)
python --version  # Should show 3.10+

# pip package manager
pip --version

# Node.js (for some tools)
node --version  # 18.0+ recommended

# Git for version control
git --version
</code></pre>
    <h3 id="browser-drivers">Browser Drivers</h3>
    <pre><code class="language-bash"># Option 1: Let Selenium Manager handle it (recommended for beginners)
pip install selenium&gt;=4.10.0  # Selenium 4.10+ has built-in driver management

# Option 2: Manual installation
# Download ChromeDriver matching your Chrome version from:
# https://chromedriver.chromium.org/downloads
</code></pre>
    <h3 id="ide-recommendations">IDE Recommendations</h3>
    <ul>
        <li><strong>VS Code</strong> with Python extension (most popular)</li>
        <li><strong>PyCharm</strong> (powerful but heavier)</li>
        <li><strong>Any editor</strong> with good Python support</li>
    </ul>
    <h3 id="creating-your-lab-environment">Creating Your Lab Environment</h3>
    <pre><code class="language-bash"># Create a dedicated directory
mkdir automation-playbook-labs
cd automation-playbook-labs

# Create virtual environment
python -m venv venv

# Activate it
# Windows:
venv\Scripts\activate
# Mac/Linux:
source venv/bin/activate

# Install base packages
pip install selenium pytest requests
</code></pre>
    <hr />
    <div class="toc-container">
        <div class="toc-title">Table of Contents</div>
        <div class="toc-grid">
            <div class="toc-part">
                <div class="toc-part-title">Part I: Foundations</div>
                <ul class="toc-chapter-list">
                    <li class="toc-chapter-item"><a href="#chapter-1-how-browsers-actually-work"
                            class="toc-chapter-link"><span class="toc-chapter-num">1.</span> How Browsers Work</a></li>
                    <li class="toc-chapter-item"><a href="#chapter-2-the-anatomy-of-a-flaky-test"
                            class="toc-chapter-link"><span class="toc-chapter-num">2.</span> Anatomy of Flakiness</a>
                    </li>
                    <li class="toc-chapter-item"><a href="#chapter-3-waitless-intelligent-stability-detection"
                            class="toc-chapter-link"><span class="toc-chapter-num">3.</span> Waitless</a></li>
                </ul>
            </div>
            <div class="toc-part">
                <div class="toc-part-title">Part II: Visual Testing</div>
                <ul class="toc-chapter-list">
                    <li class="toc-chapter-item"><a href="#chapter-4-visual-guard-pixel-perfect-regression"
                            class="toc-chapter-link"><span class="toc-chapter-num">4.</span> Visual Guard</a></li>
                </ul>
            </div>
            <div class="toc-part">
                <div class="toc-part-title">Part III: Auth Optimization</div>
                <ul class="toc-chapter-list">
                    <li class="toc-chapter-item"><a href="#chapter-5-the-hidden-cost-of-authentication"
                            class="toc-chapter-link"><span class="toc-chapter-num">5.</span> Cost of Auth</a></li>
                    <li class="toc-chapter-item"><a href="#chapter-6-selenium-teleport-restoring-state-instantly"
                            class="toc-chapter-link"><span class="toc-chapter-num">6.</span> Selenium Teleport</a></li>
                </ul>
            </div>
            <div class="toc-part">
                <div class="toc-part-title">Part IV: Stealth & Evasion</div>
                <ul class="toc-chapter-list">
                    <li class="toc-chapter-item"><a href="#chapter-7-understanding-modern-bot-detection"
                            class="toc-chapter-link"><span class="toc-chapter-num">7.</span> Bot Detection</a></li>
                    <li class="toc-chapter-item"><a href="#chapter-8-sb-stealth-wrapper-becoming-invisible"
                            class="toc-chapter-link"><span class="toc-chapter-num">8.</span> SB Stealth Wrapper</a></li>
                </ul>
            </div>
            <div class="toc-part">
                <div class="toc-part-title">Part V: Modern Architectures</div>
                <ul class="toc-chapter-list">
                    <li class="toc-chapter-item"><a href="#chapter-9-understanding-shadow-dom"
                            class="toc-chapter-link"><span class="toc-chapter-num">9.</span> Understanding Shadow
                            DOM</a></li>
                    <li class="toc-chapter-item"><a href="#chapter-10-lumos-shadowdom-illuminating-the-darkness"
                            class="toc-chapter-link"><span class="toc-chapter-num">10.</span> Lumos ShadowDOM</a></li>
                </ul>
            </div>
            <div class="toc-part">
                <div class="toc-part-title">Part VI: AI & Intelligent</div>
                <ul class="toc-chapter-list">
                    <li class="toc-chapter-item"><a href="#chapter-11-selector-scout-ai-generated-resilient-locators"
                            class="toc-chapter-link"><span class="toc-chapter-num">11.</span> Selector Scout</a></li>
                    <li class="toc-chapter-item"><a href="#chapter-12-testing-genai-chatbots-with-selenium"
                            class="toc-chapter-link"><span class="toc-chapter-num">12.</span> Testing AI Chatbots</a>
                    </li>
                    <li class="toc-chapter-item"><a
                            href="#chapter-13-pytest-mockllm-testing-ai-features-without-api-costs"
                            class="toc-chapter-link"><span class="toc-chapter-num">13.</span> Pytest-MockLLM</a></li>
                </ul>
            </div>
            <div class="toc-part">
                <div class="toc-part-title">Part VII: Visual Automation</div>
                <ul class="toc-chapter-list">
                    <li class="toc-chapter-item"><a href="#chapter-14-visual-sonar-automating-remote-desktops"
                            class="toc-chapter-link"><span class="toc-chapter-num">14.</span> Visual Sonar</a></li>
                    <li class="toc-chapter-item"><a href="#chapter-15-project-vandal-ui-mutation-testing"
                            class="toc-chapter-link"><span class="toc-chapter-num">15.</span> Project Vandal</a></li>
                </ul>
            </div>
            <div class="toc-part">
                <div class="toc-part-title">Part VIII: Reporting</div>
                <ul class="toc-chapter-list">
                    <li class="toc-chapter-item"><a href="#chapter-16-pytest-glow-report-enterprise-grade-reporting"
                            class="toc-chapter-link"><span class="toc-chapter-num">16.</span> pytest-glow-report</a>
                    </li>
                </ul>
            </div>
            <div class="toc-part">
                <div class="toc-part-title">Part IX: Enterprise Patterns</div>
                <ul class="toc-chapter-list">
                    <li class="toc-chapter-item"><a href="#chapter-17-the-four-layer-architecture"
                            class="toc-chapter-link"><span class="toc-chapter-num">17.</span> 4-Layer Architecture</a>
                    </li>
                    <li class="toc-chapter-item"><a href="#chapter-18-cicd-integration-patterns"
                            class="toc-chapter-link"><span class="toc-chapter-num">18.</span> CI/CD Patterns</a></li>
                </ul>
            </div>
            <div class="toc-part">
                <div class="toc-part-title">Part X: Specialized Env</div>
                <ul class="toc-chapter-list">
                    <li class="toc-chapter-item"><a href="#chapter-19-wvdautomation-windows-virtual-desktop"
                            class="toc-chapter-link"><span class="toc-chapter-num">19.</span> WVDAutomation</a></li>
                </ul>
            </div>
            <div class="toc-part">
                <div class="toc-part-title">Part XI: Advanced Topics</div>
                <ul class="toc-chapter-list">
                    <li class="toc-chapter-item"><a href="#chapter-20-effort-estimation-for-automation-projects"
                            class="toc-chapter-link"><span class="toc-chapter-num">20.</span> Effort Estimation</a></li>
                    <li class="toc-chapter-item"><a href="#chapter-21-sql-for-automation-testers"
                            class="toc-chapter-link"><span class="toc-chapter-num">21.</span> SQL for Testers</a></li>
                    <li class="toc-chapter-item"><a href="#chapter-22-legacy-lessons-wisdom-from-uftqtp"
                            class="toc-chapter-link"><span class="toc-chapter-num">22.</span> Legacy Lessons</a></li>
                    <li class="toc-chapter-item"><a href="#chapter-23-ai-powered-testing" class="toc-chapter-link"><span
                                class="toc-chapter-num">23.</span> AI-Powered Testing</a></li>
                </ul>
            </div>
        </div>
    </div>
    <hr />
    <h1 id="part-i-foundations">PART I: FOUNDATIONS</h1>
    <h2 id="understanding-the-platform-before-building-on-it">Understanding the Platform Before Building On It</h2>
    <blockquote>
        <p><em>"You cannot truly master a tool until you understand the substrate it operates on."</em></p>
    </blockquote>
    <p>Before writing a single line of automation code, you need to understand what's actually happening inside the
        browser. This knowledge separates automation engineers who can debug any problem from those who copy-paste Stack
        Overflow answers and hope for the best.</p>
    <hr />
    <h1 id="chapter-1-how-browsers-actually-work">Chapter 1: How Browsers Actually Work</h1>
    <h2 id="why-this-chapter-matters">Why This Chapter Matters</h2>
    <p>Every automation failure you'll ever encounter traces back to something happening inside the browser. When your
        test fails with:</p>
    <ul>
        <li><code>ElementNotInteractableException</code> â€” The browser says the element isn't ready</li>
        <li><code>StaleElementReferenceException</code> â€” The DOM changed while you were looking at it</li>
        <li><code>TimeoutException</code> â€” Something took longer than expected</li>
        <li>Element found but click doesn't work â€” Event handlers aren't attached yet</li>
    </ul>
    <p>Understanding browser internals transforms these from "random failures" into <strong>predictable, fixable
            problems</strong>.</p>
    <hr />
    <h2 id="the-browsers-multi-process-architecture">The Browser's Multi-Process Architecture</h2>
    <p>Modern browsers like Chrome are not a single programâ€”they're a <strong>collection of processes</strong> working
        together. This architecture was designed for security and stability, but it has profound implications for
        automation.</p>
    <p style="text-align: center; margin: 2rem 0;">
        <img src="/book/images/browser_architecture.png" alt="Browser Multi-Process Architecture"
            style="max-width: 100%; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);" />
    </p>
    <h3 id="the-process-model">The Process Model</h3>
    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        BROWSER PROCESS                               â”‚
â”‚  â€¢ UI (tabs, address bar, bookmarks)                                â”‚
â”‚  â€¢ Network requests                                                  â”‚
â”‚  â€¢ Storage management                                                â”‚
â”‚  â€¢ Inter-Process Communication (IPC) hub                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚                                         â”‚
             â–¼                                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     RENDERER PROCESS #1    â”‚          â”‚     RENDERER PROCESS #2    â”‚
â”‚     (Tab 1: example.com)   â”‚          â”‚     (Tab 2: google.com)    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚          â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚    Blink Engine      â”‚  â”‚          â”‚  â”‚    Blink Engine      â”‚  â”‚
â”‚  â”‚  â€¢ HTML Parser       â”‚  â”‚          â”‚  â”‚  â€¢ HTML Parser       â”‚  â”‚
â”‚  â”‚  â€¢ CSS Engine        â”‚  â”‚          â”‚  â”‚  â€¢ CSS Engine        â”‚  â”‚
â”‚  â”‚  â€¢ Layout Engine     â”‚  â”‚          â”‚  â”‚  â€¢ Layout Engine     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚          â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚          â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚    V8 JavaScript     â”‚  â”‚          â”‚  â”‚    V8 JavaScript     â”‚  â”‚
â”‚  â”‚    Engine            â”‚  â”‚          â”‚  â”‚    Engine            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚          â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    <h3 id="deep-dive-v8-bindings">ğŸ” Deep Dive: V8 Bindings & The DOM Bridge</h3>
    <p>JavaScript doesn't "own" the DOM. The DOM lives in the C++ core of the browser engine (Blink). When you call
        <code>document.getElementById()</code>, you're crossing a "bridge" from the JavaScript world (V8) to the C++
        world. This context switching is expensive. In high-frequency automation, hundreds of these crossings occur
        every second, creating a performance bottleneck that can look like network latency.</p>
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       GPU PROCESS          â”‚
â”‚  â€¢ Compositing layers      â”‚
â”‚  â€¢ WebGL rendering         â”‚
â”‚  â€¢ Video decoding          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
    <h3 id="what-this-means-for-automation">What This Means for Automation</h3>
    <p><strong>Key Insight #1: Each tab is isolated</strong></p>
    <p>When you open a new browser window or tab in Selenium, you're potentially creating a new renderer process.
        Cookies, localStorage, and JavaScript state are shared per-origin, but memory and execution are isolated.</p>
    <p><strong>Key Insight #2: JavaScript runs in the renderer process</strong></p>
    <p>When you call <code>driver.execute_script()</code>, your JavaScript runs in the renderer processâ€”the same place
        the website's JavaScript runs. This is why you can access <code>document</code>, <code>window</code>, and the
        DOM directly.</p>
    <p><strong>Key Insight #3: Network requests go through the browser process</strong></p>
    <p>This is why some bot detection techniques workâ€”they can observe network behavior at the browser level, not just
        at the page level.</p>
    <hr />
    <h2 id="the-rendering-pipeline-from-html-to-pixels">The Rendering Pipeline: From HTML to Pixels</h2>
    <p>When you navigate to a URL, here's what happens inside the browser:</p>
    <h3 id="stage-1-network-fetch">Stage 1: Network Fetch</h3>
    <pre><code>URL Entered â†’ DNS Lookup â†’ TCP Connection â†’ TLS Handshake â†’ HTTP Request â†’ Response
</code></pre>
    <p>The browser process handles this. The response (HTML, CSS, JS, images) streams back.</p>
    <h3 id="stage-2-html-parsing-and-dom-construction">Stage 2: HTML Parsing and DOM Construction</h3>
    <pre><code class="language-html">&lt;!-- This HTML... --&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;div id=&quot;container&quot;&gt;
      &lt;button id=&quot;submit&quot;&gt;Click Me&lt;/button&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
    <pre><code>&lt;!-- ...becomes this DOM tree --&gt;
Document
  â””â”€â”€ html
       â””â”€â”€ body
            â””â”€â”€ div#container
                 â””â”€â”€ button#submit
                      â””â”€â”€ TextNode: &quot;Click Me&quot;
</code></pre>
    <p><strong>ğŸ’¡ Key Insight: The DOM is a live tree structure</strong></p>
    <p>When you call <code>driver.find_element(By.ID, "submit")</code>, Selenium traverses this tree. If the tree
        changes (React re-renders, Ajax loads content), your reference might become "stale."</p>
    <h3 id="stage-3-css-parsing-and-cssom-construction">Stage 3: CSS Parsing and CSSOM Construction</h3>
    <pre><code class="language-css">/* This CSS... */
#container {
  display: flex;
}
button {
  background: blue;
  padding: 10px;
}
</code></pre>
    <pre><code>/* ...becomes the CSSOM */
StyleSheetList
  â””â”€â”€ CSSStyleSheet
       â””â”€â”€ #container { display: flex }
       â””â”€â”€ button { background: blue; padding: 10px }
</code></pre>
    <h3 id="stage-4-the-render-tree">Stage 4: The Render Tree</h3>
    <p>The DOM and CSSOM combine to create the <strong>Render Tree</strong>â€”only visible elements are included:</p>
    <pre><code>RenderTree
  â””â”€â”€ RenderBody
       â””â”€â”€ RenderDiv (display: flex)
            â””â”€â”€ RenderButton (background: blue, padding: 10px)
                 â””â”€â”€ RenderText: &quot;Click Me&quot;
</code></pre>
    <p><strong>ğŸ’¡ Key Insight: Elements with <code>display: none</code> are NOT in the render tree</strong></p>
    <p>This is why <code>element.is_displayed()</code> returns <code>False</code> for hidden elementsâ€”they literally
        don't exist in the visual representation.</p>
    <h3 id="stage-5-layout-reflow">Stage 5: Layout (Reflow)</h3>
    <p>The browser calculates the <strong>exact position and size</strong> of every element:</p>
    <pre><code>button#submit:
  x: 150px
  y: 200px
  width: 80px
  height: 40px
</code></pre>
    <p><strong>âš ï¸ Common Pitfall: Layout is expensive</strong></p>
    <p>Every time the DOM changes, layout might need to recalculate. This is why tests that rapidly modify the DOM can
        become slow.</p>
    <h3 id="stage-6-paint-and-composite">Stage 6: Paint and Composite</h3>
    <p>Finally, the browser:
        1. <strong>Paints</strong> each layer (turns elements into pixels)
        2. <strong>Composites</strong> layers together (stacking order, transparency)
        3. <strong>Sends to GPU</strong> for display</p>
    <h3 id="deep-dive-compositor-vs-main-thread">ğŸ” Deep Dive: The Compositor vs. Main Thread</h3>
    <p>A common automation mystery: <em>The element is visible, but the click fails.</em> This often happens because
        of thread contention. The <strong>Compositor Thread</strong> (which handles scrolling and some animations)
        is separate from the <strong>Main Thread</strong> (which handles JS and Layout). If the Main Thread is
        blocked by a long-running script, the browser can still <em>scroll</em> (compositor), but it cannot
        <em>process a click</em> (main thread). Automation stability requires the Main Thread to be "idle."
    </p>
    <hr />
    <h2 id="the-javascript-event-loop">The JavaScript Event Loop</h2>
    <p>This is <strong>the most important concept</strong> for understanding flaky tests.</p>
    <p style="text-align: center; margin: 2rem 0;">
        <img src="/book/images/event_loop.png" alt="JavaScript Event Loop Diagram"
            style="max-width: 100%; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);" />
    </p>
    <h3 id="the-single-threaded-nature-of-javascript">The Single-Threaded Nature of JavaScript</h3>
    <p>JavaScript in the browser runs on a <strong>single thread</strong>. There's no true parallelismâ€”everything
        happens one step at a time. But it doesn't <em>feel</em> single-threaded because of the <strong>Event
            Loop</strong>.</p>
    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         EVENT LOOP                               â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Call Stack    â”‚    â”‚           Task Queues               â”‚  â”‚
â”‚  â”‚                 â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  Currently      â”‚â—„â”€â”€â”€â”‚  â”‚ Macrotask Queue              â”‚  â”‚  â”‚
â”‚  â”‚  executing      â”‚    â”‚  â”‚ â€¢ setTimeout callbacks       â”‚  â”‚  â”‚
â”‚  â”‚  code           â”‚    â”‚  â”‚ â€¢ setInterval callbacks      â”‚  â”‚  â”‚
â”‚  â”‚                 â”‚    â”‚  â”‚ â€¢ I/O operations             â”‚  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚  â”‚ â€¢ UI rendering               â”‚  â”‚  â”‚
â”‚                         â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚                         â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚                         â”‚  â”‚ Microtask Queue              â”‚  â”‚  â”‚
â”‚                         â”‚  â”‚ â€¢ Promise callbacks          â”‚  â”‚  â”‚
â”‚                         â”‚  â”‚ â€¢ MutationObserver           â”‚  â”‚  â”‚
â”‚                         â”‚  â”‚ â€¢ queueMicrotask()           â”‚  â”‚  â”‚
â”‚                         â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
    <h3 id="how-the-event-loop-works">How the Event Loop Works</h3>
    <ol>
        <li>Execute all code in the <strong>Call Stack</strong> until it's empty</li>
        <li>Process all tasks in the <strong>Microtask Queue</strong> (Promises, MutationObserver)</li>
        <li>Process ONE task from the <strong>Macrotask Queue</strong> (setTimeout, events)</li>
        <li>Render (if needed)</li>
        <li>Repeat</li>
    </ol>
    <h3 id="why-this-matters-for-automation">Why This Matters for Automation</h3>
    <pre><code class="language-javascript">// Website code
button.addEventListener('click', async () =&gt; {
    await fetch('/api/data');  // Network request
    updateUI();  // Updates the DOM
});
</code></pre>
    <p>When your Selenium test clicks the button:</p>
    <ol>
        <li>Click event fires âœ“</li>
        <li>Event handler starts executing âœ“</li>
        <li><code>fetch()</code> is called (goes to microtask queue) âœ“</li>
        <li><strong>Event handler returns immediately</strong> âœ“</li>
        <li>Your test continues...</li>
        <li><strong>BUT the DOM hasn't updated yet!</strong></li>
    </ol>
    <p>This is the #1 cause of flaky tests: <strong>assuming synchronous completion</strong>.</p>
    <h3 id="the-solution-proper-waiting">The Solution: Proper Waiting</h3>
    <pre><code class="language-python"># âŒ BAD: Assumes synchronous completion
driver.find_element(By.ID, &quot;button&quot;).click()
result = driver.find_element(By.ID, &quot;result&quot;).text  # May fail!

# âœ… GOOD: Waits for the expected outcome
driver.find_element(By.ID, &quot;button&quot;).click()
WebDriverWait(driver, 10).until(
    EC.text_to_be_present_in_element((By.ID, &quot;result&quot;), &quot;Success&quot;)
)
</code></pre>
    <hr />
    <h2 id="page-load-events-when-is-a-page-ready">Page Load Events: When Is a Page "Ready"?</h2>
    <h3 id="the-loading-timeline">The Loading Timeline</h3>
    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     PAGE LOADING TIMELINE                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  Navigation Start                                                 â”‚
â”‚       â”‚                                                           â”‚
â”‚       â–¼                                                           â”‚
â”‚  HTML starts downloading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚       â”‚                                       â”‚                   â”‚
â”‚       â–¼                                       â–¼                   â”‚
â”‚  HTML fully parsed â—„â”€â”€â”€ DOMContentLoaded event fires              â”‚
â”‚       â”‚                                                           â”‚
â”‚       â–¼                                                           â”‚
â”‚  CSS, JS, Images loading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚       â”‚                                       â”‚                   â”‚
â”‚       â–¼                                       â–¼                   â”‚
â”‚  All resources loaded â—„â”€â”€â”€â”€â”€ load event fires                     â”‚
â”‚       â”‚                                                           â”‚
â”‚       â–¼                                                           â”‚
â”‚  Lazy resources, AJAX â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚       â”‚                                            â”‚              â”‚
â”‚       â–¼                                            â–¼              â”‚
â”‚  Fully interactive â—„â”€â”€â”€â”€â”€ NO STANDARD EVENT!                     â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
    <h3 id="what-each-event-means">What Each Event Means</h3>
    <table>
        <thead>
            <tr>
                <th>Event</th>
                <th>What's Ready</th>
                <th>What's NOT Ready</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>DOMContentLoaded</code></td>
                <td>HTML parsed, DOM built</td>
                <td>CSS, images, fonts, external JS</td>
            </tr>
            <tr>
                <td><code>load</code></td>
                <td>All initial resources</td>
                <td>Lazy-loaded content, AJAX data</td>
            </tr>
            <tr>
                <td>(no event)</td>
                <td>Everything</td>
                <td>â€”</td>
            </tr>
        </tbody>
    </table>
    <h3 id="the-problem-for-automation">The Problem for Automation</h3>
    <p>Selenium's <code>driver.get(url)</code> waits for the <code>load</code> event by default. But modern single-page
        applications often:</p>
    <ol>
        <li>Load a minimal HTML shell (triggers <code>load</code>)</li>
        <li>Execute JavaScript that fetches data</li>
        <li>Render the actual UI</li>
    </ol>
    <p>Your test starts after <code>load</code>, but the UI you need to interact with hasn't rendered yet!</p>
    <h3 id="solutions">Solutions</h3>
    <pre><code class="language-python"># Strategy 1: Wait for specific elements
driver.get(&quot;https://example.com&quot;)
WebDriverWait(driver, 20).until(
    EC.presence_of_element_located((By.ID, &quot;main-content&quot;))
)

# Strategy 2: Wait for network idle (using JavaScript)
driver.get(&quot;https://example.com&quot;)
driver.execute_script(&quot;&quot;&quot;
    return new Promise(resolve =&gt; {
        if (document.readyState === 'complete') {
            setTimeout(resolve, 500);  // Small buffer for AJAX
        } else {
            window.addEventListener('load', () =&gt; setTimeout(resolve, 500));
        }
    });
&quot;&quot;&quot;)

# Strategy 3: Use Waitless (covered in Chapter 3)
from waitless import stabilize
driver = stabilize(webdriver.Chrome())
driver.get(&quot;https://example.com&quot;)  # Automatically waits for full stability
</code></pre>
    <hr />
    <h2 id="how-webdriver-selenium-talks-to-the-browser">How WebDriver (Selenium) Talks to the Browser</h2>
    <p>Understanding this communication protocol helps debug "weird" failures.</p>
    <h3 id="the-webdriver-protocol">The WebDriver Protocol</h3>
    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     HTTP/REST      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                 â”‚
â”‚   Your Test     â”‚   {&quot;using&quot;: &quot;id&quot;,  â”‚   ChromeDriver  â”‚
â”‚   (Python)      â”‚    &quot;value&quot;: &quot;btn&quot;} â”‚   (Executable)  â”‚
â”‚                 â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   {&quot;value&quot;: {...}} â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                â”‚
                                                â”‚ Chrome DevTools
                                                â”‚ Protocol (CDP)
                                                â”‚
                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                                        â”‚                â”‚
                                        â”‚     Chrome     â”‚
                                        â”‚    Browser     â”‚
                                        â”‚                â”‚
                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
    <h3 id="what-happens-when-you-call-find_element">What Happens When You Call <code>find_element()</code></h3>
    <pre><code class="language-python">element = driver.find_element(By.ID, &quot;submit-button&quot;)
</code></pre>
    <ol>
        <li><strong>Your code</strong> calls Selenium's Python binding</li>
        <li><strong>Selenium</strong> sends HTTP POST to ChromeDriver:
            <code>json
   POST /session/{sessionId}/element
   {"using": "css selector", "value": "#submit-button"}</code>
        </li>
        <li><strong>ChromeDriver</strong> translates to CDP command</li>
        <li><strong>Chrome</strong> executes <code>document.querySelector("#submit-button")</code></li>
        <li><strong>Chrome</strong> returns element reference to ChromeDriver</li>
        <li><strong>ChromeDriver</strong> returns JSON response:
            <code>json
   {"value": {"element-6066-11e4-a52e-4f735466cecf": "abc123"}}</code>
        </li>
        <li><strong>Selenium</strong> wraps this in a <code>WebElement</code> object</li>
    </ol>
    <h3 id="why-elements-become-stale">Why Elements Become "Stale"</h3>
    <p>That <code>"abc123"</code> is a <strong>reference ID</strong>. If the DOM element is removed and re-added (common
        in React/Vue/Angular), the old reference ID is invalidâ€”hence <code>StaleElementReferenceException</code>.</p>
    <hr />
    <h2 id="the-chrome-devtools-protocol-cdp">The Chrome DevTools Protocol (CDP)</h2>
    <p>Selenium 4 introduced direct CDP access, unlocking powerful capabilities:</p>
    <pre><code class="language-python"># Traditional WebDriver (limited)
driver.get(&quot;https://example.com&quot;)

# Direct CDP access (powerful)
driver.execute_cdp_cmd(&quot;Network.enable&quot;, {})
driver.execute_cdp_cmd(&quot;Network.setExtraHTTPHeaders&quot;, {
    &quot;headers&quot;: {&quot;X-Custom-Header&quot;: &quot;my-value&quot;}
})

# Listen to network events
driver.execute_cdp_cmd(&quot;Network.enable&quot;, {})
# Now you can capture all network requests/responses
</code></pre>
    <h3 id="key-cdp-domains-for-testing">Key CDP Domains for Testing</h3>
    <table>
        <thead>
            <tr>
                <th>Domain</th>
                <th>Capabilities</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>Network</code></td>
                <td>Intercept requests, mock responses, throttle bandwidth</td>
            </tr>
            <tr>
                <td><code>DOM</code></td>
                <td>Query/modify DOM, track mutations</td>
            </tr>
            <tr>
                <td><code>Performance</code></td>
                <td>Collect metrics, trace execution</td>
            </tr>
            <tr>
                <td><code>Console</code></td>
                <td>Capture console.log output</td>
            </tr>
            <tr>
                <td><code>Emulation</code></td>
                <td>Spoof device, geolocation, timezone</td>
            </tr>
        </tbody>
    </table>
    <hr />
    <h3 id="the-hidden-latency-cost-of-a-webdriver-command">ğŸ” Deep Dive: The Hidden Latency - Cost of a WebDriver
        Command</h3>
    <p>Every Selenium command (e.g., <code>element.is_displayed()</code>) is an out-of-process network call. Even
        on localhost, there is overhead for serialization, network transmission, and deserialization. When you put a
        <code>find_element</code> call inside a tight loop, you're not just waiting for the browser; you're paying a
        "tax" of 5-10ms per call just for the communication protocol itself. This is why batching interactions in
        JavaScript (using <code>execute_script</code>) is often 10x faster for complex tasks.
    </p>
    <hr />
    <h2 id="hands-on-exercise-exploring-browser-internals">ğŸ”§ Hands-On Exercise: Exploring Browser Internals</h2>
    <p>Let's apply what we've learned:</p>
    <pre><code class="language-python">from selenium import webdriver
from selenium.webdriver.common.by import By
import time

driver = webdriver.Chrome()

# 1. Navigate and observe loading
driver.get(&quot;https://example.com&quot;)
print(f&quot;Page load complete. Title: {driver.title}&quot;)

# 2. Explore the DOM
dom_html = driver.execute_script(&quot;return document.documentElement.outerHTML.length&quot;)
print(f&quot;Total DOM size: {dom_html} characters&quot;)

# 3. Check event loop status
pending_tasks = driver.execute_script(&quot;&quot;&quot;
    return {
        readyState: document.readyState,
        animationsPending: document.getAnimations().filter(a =&gt; a.playState === 'running').length
    }
&quot;&quot;&quot;)
print(f&quot;Document state: {pending_tasks['readyState']}&quot;)
print(f&quot;Running animations: {pending_tasks['animationsPending']}&quot;)

# 4. Monitor a mutation
driver.execute_script(&quot;&quot;&quot;
    window.__mutations = [];
    const observer = new MutationObserver(mutations =&gt; {
        mutations.forEach(m =&gt; window.__mutations.push(m.type));
    });
    observer.observe(document.body, {childList: true, subtree: true});
&quot;&quot;&quot;)

# Make a DOM change
driver.execute_script(&quot;document.body.innerHTML += '&lt;div&gt;Test&lt;/div&gt;'&quot;)

mutations = driver.execute_script(&quot;return window.__mutations&quot;)
print(f&quot;Mutations observed: {mutations}&quot;)

driver.quit()
</code></pre>
    <p><strong>Expected Output:</strong></p>
    <pre><code>Page load complete. Title: Example Domain
Total DOM size: 1234 characters
Document state: complete
Running animations: 0
Mutations observed: ['childList']
</code></pre>
    <hr />
    <h2 id="chapter-1-summary">ğŸ“‹ Chapter 1 Summary</h2>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Key Takeaway</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Multi-Process Architecture</td>
                <td>Each tab runs in isolation; crashes don't affect other tabs</td>
            </tr>
            <tr>
                <td>Rendering Pipeline</td>
                <td>HTML â†’ DOM â†’ CSSOM â†’ Render Tree â†’ Layout â†’ Paint</td>
            </tr>
            <tr>
                <td>Event Loop</td>
                <td>Single-threaded but async; explains why clicks don't wait</td>
            </tr>
            <tr>
                <td>Page Load Events</td>
                <td><code>load</code> event fires before AJAX content is ready</td>
            </tr>
            <tr>
                <td>WebDriver Protocol</td>
                <td>HTTP/JSON commands translated to CDP</td>
            </tr>
            <tr>
                <td>Stale Elements</td>
                <td>DOM changes invalidate element references</td>
            </tr>
        </tbody>
    </table>
    <p><strong>Coming up next:</strong> Now that you understand the platform, let's explore why tests fail
        unpredictablyâ€”and how to analyze the root cause.</p>
    <hr />
    <h1 id="chapter-2-the-anatomy-of-a-flaky-test">Chapter 2: The Anatomy of a Flaky Test</h1>
    <h2 id="understanding-why-tests-fail-intermittently">Understanding Why Tests Fail Intermittently</h2>
    <p>Flaky tests are the silent killers of automation credibility. A test that passes on Monday, fails on Tuesday, and
        passes again on Wednesdayâ€”with zero code changesâ€”destroys trust faster than any bug in production.</p>
    <h3 id="the-true-cost-of-flakiness">The True Cost of Flakiness</h3>
    <p>Consider these statistics from real enterprise environments:</p>
    <table>
        <thead>
            <tr>
                <th>Metric</th>
                <th>Impact</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Developer time investigating false failures</td>
                <td>4-6 hours/week per engineer</td>
            </tr>
            <tr>
                <td>Pipeline re-runs due to flaky tests</td>
                <td>15-25% of all runs</td>
            </tr>
            <tr>
                <td>Confidence in test results</td>
                <td>Drops below 60%</td>
            </tr>
            <tr>
                <td>Time to detect real bugs</td>
                <td>Increases by 40%</td>
            </tr>
        </tbody>
    </table>
    <p>When developers stop trusting test results, they stop looking at them. The automation suite becomes expensive
        decoration.</p>
    <h3 id="key-insight-flakiness-is-a-symptom-not-a-disease">ğŸ’¡ Key Insight: Flakiness Is a Symptom, Not a Disease</h3>
    <p>Every flaky test has a <strong>deterministic root cause</strong>. The test isn't "randomly" failingâ€”it's failing
        because of specific conditions that aren't always present. Your job is to find those conditions.</p>
    <h3 id="deep-dive-micro-stutter-gc-and-jit">ğŸ” Deep Dive: The Micro-Stutter - GC and JIT Interference</h3>
    <p>Sometimes the browser itself stops responding for a few milliseconds. This happens during <strong>Garbage
            Collection (GC)</strong>â€”when V8 pauses execution to clean up memoryâ€”or <strong>Just-In-Time (JIT)
            Compilation</strong>. These "micro-stutters" are nearly invisible to humans but can cause a race
        condition to trigger in automation if the browser pauses exactly when a click is being sent. Stable automation
        builds in a small buffer for these unavoidable internal pauses.</p>
    <hr />
    <h2 id="root-cause-analysis-the-five-categories-of-flakiness">Root Cause Analysis: The Five Categories of Flakiness
    </h2>
    <h3 id="category-1-race-conditions-40-of-flaky-tests">Category 1: Race Conditions (40% of flaky tests)</h3>
    <p>The browser and test script operate at different speeds. The script says "click the button" before the button is
        ready.</p>
    <p><strong>Symptoms:</strong>
        - <code>ElementNotInteractableException</code>
        - <code>StaleElementReferenceException</code>
        - Tests pass locally, fail in CI</p>
    <p><strong>Example of the Problem:</strong></p>
    <pre><code class="language-python"># This code has a race condition
driver.get(&quot;https://app.example.com/dashboard&quot;)
driver.find_element(By.ID, &quot;submit-btn&quot;).click()  # May fail!
</code></pre>
    <p>The page is still loading when the click executes. The element might:
        - Not exist in the DOM yet
        - Exist but be covered by a loading overlay
        - Exist but be outside the viewport
        - Exist but have event handlers not yet attached</p>
    <p><strong>ğŸ” Deep Dive: Why Event Handlers Aren't Attached Immediately</strong></p>
    <pre><code class="language-html">&lt;button id=&quot;submit-btn&quot;&gt;Submit&lt;/button&gt;
&lt;script&gt;
    // This runs after the button exists in DOM
    document.getElementById('submit-btn').addEventListener('click', handleClick);
&lt;/script&gt;
</code></pre>
    <p>The button is in the DOM immediately, but the event listener is only attached when the
        <code>&lt;script&gt;</code> executes. If your test clicks before the script runs, nothing happens!
    </p>
    <p><strong>Solution Pattern:</strong></p>
    <pre><code class="language-python">from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# Wait for element to be clickable (visible + enabled)
wait = WebDriverWait(driver, 10)
button = wait.until(EC.element_to_be_clickable((By.ID, &quot;submit-btn&quot;)))
button.click()
</code></pre>
    <hr />
    <h3 id="category-2-network-variability-25-of-flaky-tests">Category 2: Network Variability (25% of flaky tests)</h3>
    <p>API calls complete at different speeds. A dashboard that loads in 200ms locally might take 2 seconds in CI.</p>
    <p><strong>Symptoms:</strong>
        - Tests timeout in CI but pass locally
        - Intermittent failures correlate with time of day
        - Tests fail more often on shared CI infrastructure</p>
    <p><strong>Why CI Is Different:</strong></p>
    <table>
        <thead>
            <tr>
                <th>Factor</th>
                <th>Local Development</th>
                <th>CI Environment</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Network Latency</td>
                <td>Near-zero (localhost)</td>
                <td>Variable (shared infra)</td>
            </tr>
            <tr>
                <td>CPU</td>
                <td>Dedicated</td>
                <td>Shared with other jobs</td>
            </tr>
            <tr>
                <td>Memory</td>
                <td>Abundant</td>
                <td>Often limited</td>
            </tr>
            <tr>
                <td>Browser Startup</td>
                <td>Instant (browser cached)</td>
                <td>Cold start each time</td>
            </tr>
        </tbody>
    </table>
    <p><strong>Solution Pattern:</strong></p>
    <pre><code class="language-python"># âŒ BAD: Fixed timeout too short
wait = WebDriverWait(driver, 3)

# âœ… GOOD: Generous timeout with early exit
wait = WebDriverWait(driver, 30)  # Will return early if condition met
element = wait.until(EC.presence_of_element_located((By.ID, &quot;data-loaded&quot;)))
</code></pre>
    <hr />
    <h3 id="category-3-animation-interference-15-of-flaky-tests">Category 3: Animation Interference (15% of flaky tests)
    </h3>
    <p>CSS transitions and JavaScript animations don't block Selenium. The test clicks where the button <em>will
            be</em>, not where it <em>is</em>.</p>
    <p><strong>Example:</strong></p>
    <pre><code class="language-css">.modal {
    transition: transform 0.3s ease-in-out;
    transform: translateY(-100%);
}
.modal.open {
    transform: translateY(0);
}
</code></pre>
    <p>The modal slides in over 300ms. Selenium doesn't wait for CSS transitions.</p>
    <p><strong>ğŸ” Deep Dive: How Animations Break Clicks</strong></p>
    <ol>
        <li>Test finds element at position (100, 500) - where modal WILL be</li>
        <li>Browser reports element as "visible" because <code>opacity &gt; 0</code> and <code>display != none</code>
        </li>
        <li>Test sends click command to coordinates (100, 500)</li>
        <li>Animation is still in progress - element is actually at (100, 350)</li>
        <li>Click hits wrong element or nothing</li>
    </ol>
    <p><strong>Solution Pattern:</strong></p>
    <pre><code class="language-python"># Wait for all animations to complete
def wait_for_animations(driver):
    driver.execute_script(&quot;&quot;&quot;
        return new Promise(resolve =&gt; {
            const checkAnimations = () =&gt; {
                const animations = document.getAnimations();
                const running = animations.filter(a =&gt; a.playState === 'running');
                if (running.length === 0) {
                    resolve();
                } else {
                    requestAnimationFrame(checkAnimations);
                }
            };
            checkAnimations();
        });
    &quot;&quot;&quot;)

# Usage
driver.find_element(By.CLASS_NAME, &quot;open-modal&quot;).click()
wait_for_animations(driver)
modal_button = driver.find_element(By.ID, &quot;modal-confirm&quot;)
modal_button.click()
</code></pre>
    <hr />
    <h3 id="category-4-external-dependencies-10-of-flaky-tests">Category 4: External Dependencies (10% of flaky tests)
    </h3>
    <ul>
        <li>Third-party services (payment gateways, OAuth providers)</li>
        <li>Shared databases with concurrent test runs</li>
        <li>Time-dependent logic (tests fail at midnight)</li>
    </ul>
    <p><strong>Solution Patterns:</strong></p>
    <pre><code class="language-python"># 1. Mock external services
@pytest.fixture
def mock_payment_gateway():
    with responses.RequestsMock() as rsps:
        rsps.add(
            responses.POST, 
            &quot;https://api.stripe.com/v1/charges&quot;,
            json={&quot;id&quot;: &quot;ch_test123&quot;, &quot;status&quot;: &quot;succeeded&quot;},
            status=200
        )
        yield rsps

# 2. Isolate database
@pytest.fixture
def isolated_db_session():
    # Create unique schema per test
    schema_name = f&quot;test_{uuid.uuid4().hex[:8]}&quot;
    create_schema(schema_name)
    yield schema_name
    drop_schema(schema_name)

# 3. Control time
from freezegun import freeze_time

@freeze_time(&quot;2024-06-15 14:30:00&quot;)
def test_discount_during_sale_period():
    # Time-sensitive logic now predictable
    assert calculate_discount() == 0.20
</code></pre>
    <hr />
    <h3 id="category-5-resource-contention-10-of-flaky-tests">Category 5: Resource Contention (10% of flaky tests)</h3>
    <ul>
        <li>Insufficient memory causing slow garbage collection</li>
        <li>CPU contention on shared CI runners</li>
        <li>Browser instance limits exceeded</li>
    </ul>
    <p><strong>Symptoms:</strong>
        - Failures cluster at certain times (when CI is busy)
        - Memory-related crashes
        - "Chrome not reachable" errors</p>
    <p><strong>Solution Patterns:</strong></p>
    <pre><code class="language-python"># 1. Request dedicated CI resources
# .github/workflows/test.yml
jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      CHROME_ARGS: &quot;--disable-dev-shm-usage --no-sandbox&quot;

# 2. Limit parallel browser instances
# pytest.ini
[pytest]
addopts = -n 4  # Max 4 parallel workers

# 3. Add resource monitoring
import psutil

def check_system_resources():
    memory = psutil.virtual_memory()
    if memory.percent &gt; 90:
        logging.warning(f&quot;High memory usage: {memory.percent}%&quot;)
        # Consider failing fast rather than flaking
</code></pre>
    <hr />
    <h2 id="the-traditional-solutions-and-why-they-dont-work">The Traditional Solutions (And Why They Don't Work)</h2>
    <h3 id="solution-1-timesleep-the-worst-fix">Solution 1: <code>time.sleep()</code> - The Worst Fix</h3>
    <pre><code class="language-python">driver.get(&quot;https://app.example.com/dashboard&quot;)
time.sleep(5)  # &quot;This should be enough time&quot;
driver.find_element(By.ID, &quot;submit-btn&quot;).click()
</code></pre>
    <p><strong>Problems:</strong>
        - <strong>Too slow</strong>: You wait 5 seconds even when the page loads in 500ms
        - <strong>Still flaky</strong>: Sometimes 5 seconds isn't enough
        - <strong>Compounds</strong>: 100 tests Ã— 3 sleeps each Ã— 5 seconds = <strong>25 minutes wasted</strong></p>
    <h3 id="solution-2-explicit-waits-better-but-incomplete">Solution 2: Explicit Waits - Better But Incomplete</h3>
    <pre><code class="language-python">from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

wait = WebDriverWait(driver, 10)
element = wait.until(
    EC.element_to_be_clickable((By.ID, &quot;submit-btn&quot;))
)
element.click()
</code></pre>
    <p><strong>Improvements:</strong>
        - Returns as soon as condition is met
        - Has a timeout for failure cases
        - More descriptive failures</p>
    <p><strong>Remaining Problems:</strong>
        - Doesn't wait for network calls to complete
        - Doesn't wait for animations to finish
        - Doesn't detect JavaScript-driven readiness
        - Requires explicit waits everywhere in code</p>
    <h3 id="solution-3-custom-expected-conditions-high-maintenance">Solution 3: Custom Expected Conditions - High
        Maintenance</h3>
    <pre><code class="language-python">class all_animations_complete:
    def __call__(self, driver):
        return driver.execute_script(&quot;&quot;&quot;
            return document.getAnimations().every(a =&gt; 
                a.playState === 'finished' || a.playState === 'idle'
            );
        &quot;&quot;&quot;)

wait.until(all_animations_complete())
</code></pre>
    <p><strong>Problems:</strong>
        - Must remember to add this everywhere
        - Doesn't handle network calls
        - Complex to maintain across team</p>
    <hr />
    <h2 id="the-diagnostic-toolkit">The Diagnostic Toolkit</h2>
    <p>Before jumping to solutions, you need to diagnose the specific cause of flakiness.</p>
    <h3 id="tool-1-retry-analysis">Tool 1: Retry Analysis</h3>
    <p>Run the flaky test 50+ times and analyze patterns:</p>
    <pre><code class="language-python"># pytest_flaky_tracker.py
import pytest
import json
from datetime import datetime

RESULTS_FILE = &quot;flaky_analysis.json&quot;

@pytest.hookimpl(hookwrapper=True)
def pytest_runtest_makereport(item, call):
    outcome = yield
    report = outcome.get_result()

    if call.when == &quot;call&quot;:
        result = {
            &quot;test&quot;: item.name,
            &quot;timestamp&quot;: datetime.now().isoformat(),
            &quot;passed&quot;: report.passed,
            &quot;duration&quot;: report.duration,
            &quot;error&quot;: str(report.longrepr) if report.failed else None
        }

        # Append to results file
        try:
            with open(RESULTS_FILE, &quot;r&quot;) as f:
                data = json.load(f)
        except FileNotFoundError:
            data = []

        data.append(result)

        with open(RESULTS_FILE, &quot;w&quot;) as f:
            json.dump(data, f, indent=2)
</code></pre>
    <p>Run analysis:</p>
    <pre><code class="language-bash">for i in {1..50}; do pytest test_flaky.py --tb=short; done
python analyze_flaky.py  # Analyze patterns
</code></pre>
    <h3 id="tool-2-screenshot-on-failure">Tool 2: Screenshot on Failure</h3>
    <pre><code class="language-python">@pytest.fixture
def driver(request):
    driver = webdriver.Chrome()
    yield driver

    # Capture screenshot on failure
    if request.node.rep_call.failed:
        screenshot_dir = Path(&quot;screenshots&quot;)
        screenshot_dir.mkdir(exist_ok=True)

        filename = f&quot;{request.node.name}_{datetime.now():%Y%m%d_%H%M%S}.png&quot;
        driver.save_screenshot(str(screenshot_dir / filename))

    driver.quit()

@pytest.hookimpl(tryfirst=True, hookwrapper=True)
def pytest_runtest_makereport(item, call):
    outcome = yield
    rep = outcome.get_result()
    setattr(item, f&quot;rep_{rep.when}&quot;, rep)
</code></pre>
    <h3 id="tool-3-network-log-capture">Tool 3: Network Log Capture</h3>
    <pre><code class="language-python">def enable_network_logging(driver):
    driver.execute_cdp_cmd(&quot;Network.enable&quot;, {})

def get_pending_requests(driver):
    # This requires more complex CDP subscription setup
    logs = driver.execute_script(&quot;&quot;&quot;
        return window.performance.getEntriesByType('resource')
            .filter(e =&gt; e.responseEnd === 0)
            .map(e =&gt; e.name);
    &quot;&quot;&quot;)
    return logs
</code></pre>
    <hr />
    <h2 id="chapter-2-summary">ğŸ“‹ Chapter 2 Summary</h2>
    <table>
        <thead>
            <tr>
                <th>Flakiness Category</th>
                <th>Percentage</th>
                <th>Primary Solution</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Race Conditions</td>
                <td>40%</td>
                <td>Explicit waits for expected state</td>
            </tr>
            <tr>
                <td>Network Variability</td>
                <td>25%</td>
                <td>Generous timeouts, network mocking</td>
            </tr>
            <tr>
                <td>Animation Interference</td>
                <td>15%</td>
                <td>Wait for <code>getAnimations()</code> to settle</td>
            </tr>
            <tr>
                <td>External Dependencies</td>
                <td>10%</td>
                <td>Mock services, isolate data</td>
            </tr>
            <tr>
                <td>Resource Contention</td>
                <td>10%</td>
                <td>Dedicated resources, monitoring</td>
            </tr>
        </tbody>
    </table>
    <p><strong>The Ultimate Solution:</strong> In the next chapter, we'll introduce <strong>Waitless</strong>, which
        addresses race conditions, network variability, AND animation interference automaticallyâ€”with no code changes
        required.</p>
    <hr />
    <h1 id="chapter-3-waitless-intelligent-stability-detection">Chapter 3: Waitless - Intelligent Stability Detection
    </h1>
    <h2 id="a-fundamentally-different-approach">A Fundamentally Different Approach</h2>
    <p>Instead of telling Selenium when to wait, <strong>Waitless</strong> instruments the browser itself to detect when
        waiting is no longer needed.</p>
    <h3 id="the-core-philosophy">The Core Philosophy</h3>
    <p>Traditional approaches ask: <em>"What should I wait for?"</em></p>
    <p>Waitless asks: <em>"What signals indicate the page is stable?"</em></p>
    <p><strong>The three signals of stability:</strong>
        1. <strong>DOM settled</strong> â€” No elements being added/removed/modified
        2. <strong>Network idle</strong> â€” No pending HTTP requests
        3. <strong>Animations complete</strong> â€” No CSS or JavaScript animations running</p>
    <p>When all three are true, the page is ready for interaction.</p>
    <hr />
    <h2 id="the-architecture">ğŸ” Deep Dive: The Waitless Architecture</h2>
    <p style="text-align: center; margin: 2rem 0;">
        <img src="/book/images/waitless_architecture.png" alt="Waitless Architecture"
            style="max-width: 100%; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);" />
    </p>
    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      YOUR TEST CODE                              â”‚
â”‚  driver.find_element(By.ID, &quot;btn&quot;).click()                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   WAITLESS WRAPPER                               â”‚
â”‚  â€¢ Intercepts all WebDriver commands                            â”‚
â”‚  â€¢ Injects stability checks before each action                  â”‚
â”‚  â€¢ No code changes required in your tests                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              BROWSER-SIDE INSTRUMENTATION                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚    Mutation     â”‚ â”‚    Network      â”‚ â”‚   Animation     â”‚   â”‚
â”‚  â”‚    Observer     â”‚ â”‚   Interceptor   â”‚ â”‚    Tracker      â”‚   â”‚
â”‚  â”‚                 â”‚ â”‚                 â”‚ â”‚                 â”‚   â”‚
â”‚  â”‚ Watches DOM     â”‚ â”‚ Tracks XHR &amp;    â”‚ â”‚ Monitors CSS &amp;  â”‚   â”‚
â”‚  â”‚ changes via     â”‚ â”‚ Fetch pending   â”‚ â”‚ JS animations   â”‚   â”‚
â”‚  â”‚ MutationObserverâ”‚ â”‚ requests        â”‚ â”‚                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚                    STABILITY ORACLE                              â”‚
â”‚         &quot;Is everything settled? Yes â†’ Proceed&quot;                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
    <hr />
    <h2 id="installation-and-basic-usage">Installation and Basic Usage</h2>
    <pre><code class="language-bash">pip install waitless
</code></pre>
    <pre><code class="language-python">from selenium import webdriver
from waitless import stabilize

# Wrap your driver once at the start
driver = stabilize(webdriver.Chrome())

# All subsequent commands automatically wait for stability
driver.get(&quot;https://app.example.com&quot;)
driver.find_element(By.ID, &quot;dynamic-button&quot;).click()  # Stable!
driver.find_element(By.ID, &quot;ajax-loaded-element&quot;).send_keys(&quot;text&quot;)  # Stable!
</code></pre>
    <p><strong>That's it.</strong> No explicit waits. No sleep statements. The driver automatically waits for stability
        before every action.</p>
    <hr />
    <h2 id="deep-dive-how-each-component-works">ğŸ” Deep Dive: How Each Component Works</h2>
    <h3 id="component-1-dom-mutation-observer">Component 1: DOM Mutation Observer</h3>
    <p>The <code>MutationObserver</code> API watches for changes to the DOM tree:</p>
    <pre><code class="language-javascript">// Injected by Waitless into the browser
(function() {
    window.__waitless_last_mutation = Date.now();
    window.__waitless_mutation_count = 0;

    const observer = new MutationObserver((mutations) =&gt; {
        window.__waitless_mutation_count += mutations.length;
        window.__waitless_last_mutation = Date.now();
    });

    observer.observe(document.body, {
        childList: true,    // Watch for added/removed elements
        subtree: true,      // Watch entire DOM tree
        attributes: true,   // Watch attribute changes
        characterData: true // Watch text content changes
    });
})();
</code></pre>
    <p><strong>Stability Criteria:</strong> No mutations for 100ms (configurable).</p>
    <p><strong>Why 100ms?</strong> React, Vue, and Angular typically batch multiple DOM updates within a single
        animation frame (16ms). The 100ms buffer ensures all related updates have completed.</p>
    <h3 id="component-2-network-interceptor">Component 2: Network Interceptor</h3>
    <p>Waitless intercepts <code>XMLHttpRequest</code> and <code>fetch</code> to track pending requests:</p>
    <pre><code class="language-javascript">// XMLHttpRequest interception
(function() {
    window.__waitless_pending_requests = 0;

    const originalXHROpen = XMLHttpRequest.prototype.open;
    const originalXHRSend = XMLHttpRequest.prototype.send;

    XMLHttpRequest.prototype.open = function(...args) {
        this.__waitless_url = args[1];
        return originalXHROpen.apply(this, args);
    };

    XMLHttpRequest.prototype.send = function(...args) {
        window.__waitless_pending_requests++;

        this.addEventListener('loadend', () =&gt; {
            window.__waitless_pending_requests--;
        });

        return originalXHRSend.apply(this, args);
    };

    // Fetch interception
    const originalFetch = window.fetch;
    window.fetch = function(...args) {
        window.__waitless_pending_requests++;

        return originalFetch.apply(this, args)
            .finally(() =&gt; {
                window.__waitless_pending_requests--;
            });
    };
})();
</code></pre>
    <p><strong>Stability Criteria:</strong> Zero pending requests.</p>
    <h3 id="component-3-animation-tracker">Component 3: Animation Tracker</h3>
    <p>Tracks CSS animations and JavaScript animations:</p>
    <pre><code class="language-javascript">(function() {
    window.__waitless_active_animations = 0;

    // CSS Animation tracking
    document.addEventListener('animationstart', () =&gt; {
        window.__waitless_active_animations++;
    });

    document.addEventListener('animationend', () =&gt; {
        window.__waitless_active_animations--;
    });

    document.addEventListener('transitionstart', () =&gt; {
        window.__waitless_active_animations++;
    });

    document.addEventListener('transitionend', () =&gt; {
        window.__waitless_active_animations--;
    });
})();

// Web Animations API check
const getActiveAnimations = () =&gt; {
    return document.getAnimations().filter(a =&gt; 
        a.playState === 'running'
    ).length;
};
</code></pre>
    <p><strong>Stability Criteria:</strong> Zero running animations.</p>
    <hr />
    <h2 id="configuration-options">Configuration Options</h2>
    <pre><code class="language-python">from waitless import stabilize, StabilityConfig

config = StabilityConfig(
    # Timing controls
    mutation_settle_time=100,      # ms to wait after last DOM change
    network_idle_time=50,          # ms to wait after last network request
    animation_settle_time=50,      # ms to wait after last animation

    # Safety limits
    max_wait_time=30000,           # maximum wait time in ms
    poll_interval=50,              # how often to check stability

    # URL filtering (ignore analytics, monitoring, etc.)
    ignore_urls=[
        r&quot;.*google-analytics.*&quot;,
        r&quot;.*googletagmanager.*&quot;,
        r&quot;.*hotjar.*&quot;,
        r&quot;.*sentry.*&quot;,
        r&quot;.*datadog.*&quot;
    ]
)

driver = stabilize(webdriver.Chrome(), config=config)
</code></pre>
    <h3 id="when-to-adjust-configuration">When to Adjust Configuration</h3>
    <table>
        <thead>
            <tr>
                <th>Scenario</th>
                <th>Adjustment</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Very slow API responses</td>
                <td>Increase <code>max_wait_time</code></td>
            </tr>
            <tr>
                <td>Complex animations</td>
                <td>Increase <code>animation_settle_time</code></td>
            </tr>
            <tr>
                <td>Analytics causing false positives</td>
                <td>Add URLs to <code>ignore_urls</code></td>
            </tr>
            <tr>
                <td>Need faster feedback</td>
                <td>Decrease <code>poll_interval</code> (use cautiously)</td>
            </tr>
        </tbody>
    </table>
    <hr />
    <h2 id="debugging-stability-issues">Debugging Stability Issues</h2>
    <p>When a test still fails, Waitless provides diagnostic information:</p>
    <pre><code class="language-python">from waitless import get_diagnostics

# After a test failure, check what was unstable
diagnostics = get_diagnostics(driver)

print(f&quot;Pending network requests: {diagnostics['pending_requests']}&quot;)
print(f&quot;Last mutation age: {diagnostics['ms_since_last_mutation']}ms&quot;)
print(f&quot;Active animations: {diagnostics['active_animations']}&quot;)
print(f&quot;Blocking URLs: {diagnostics['blocking_urls']}&quot;)
</code></pre>
    <p><strong>Example output for a failing test:</strong></p>
    <pre><code>Pending network requests: 2
Last mutation age: 15ms
Active animations: 0
Blocking URLs: ['/api/user/profile', '/api/notifications']
</code></pre>
    <p>This tells you the page wasn't stable because two API calls were still pending.</p>
    <hr />
    <p style="text-align: center; margin: 2rem 0;">
        <img src="/book/images/stability.png" alt="Test Stability Visualization"
            style="max-width: 100%; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);" />
    </p>
    <h2 id="real-world-impact">Real-World Impact</h2>
    <p><strong>Before Waitless:</strong></p>
    <pre><code>Test Suite: checkout_flow (5 tests)
â”œâ”€â”€ test_add_to_cart        PASSED
â”œâ”€â”€ test_update_quantity    FAILED (StaleElementReference)
â”œâ”€â”€ test_apply_coupon       PASSED
â”œâ”€â”€ test_checkout           FAILED (ElementNotInteractable)
â””â”€â”€ test_payment            PASSED

Run 1: 60% pass rate
Run 2: 80% pass rate  
Run 3: 40% pass rate
Average: 60% (Expected: 100%)
Re-runs required: 3-4 per CI pipeline
</code></pre>
    <p><strong>After Waitless:</strong></p>
    <pre><code>Test Suite: checkout_flow (5 tests)
â”œâ”€â”€ test_add_to_cart        PASSED
â”œâ”€â”€ test_update_quantity    PASSED
â”œâ”€â”€ test_apply_coupon       PASSED
â”œâ”€â”€ test_checkout           PASSED
â””â”€â”€ test_payment            PASSED

Run 1-100: 100% pass rate
Flaky failures eliminated: 100%
Re-runs required: 0
</code></pre>
    <hr />
    <h2 id="common-pitfalls">âš ï¸ Common Pitfalls</h2>
    <h3 id="pitfall-1-long-polling-websockets">Pitfall 1: Long-Polling / WebSockets</h3>
    <p>If your app uses long-polling or maintains open WebSocket connections, Waitless may wait indefinitely for
        "network idle."</p>
    <p><strong>Solution:</strong></p>
    <pre><code class="language-python">config = StabilityConfig(
    ignore_urls=[
        r&quot;.*socket.*&quot;,
        r&quot;.*poll.*&quot;,
        r&quot;.*long-poll.*&quot;
    ]
)
</code></pre>
    <h3 id="pitfall-2-infinite-animations">Pitfall 2: Infinite Animations</h3>
    <p>Loading spinners and animated backgrounds never "complete."</p>
    <p><strong>Solution:</strong></p>
    <pre><code class="language-python"># Waitless ignores animations on elements with these classes
config = StabilityConfig(
    ignore_animation_selectors=[
        &quot;.loading-spinner&quot;,
        &quot;.animated-background&quot;,
        &quot;[data-infinite-animation]&quot;
    ]
)
</code></pre>
    <h3 id="pitfall-3-analytics-calls">Pitfall 3: Analytics Calls</h3>
    <p>Google Analytics, Hotjar, and other analytics tools make constant requests.</p>
    <p><strong>Solution:</strong></p>
    <pre><code class="language-python">config = StabilityConfig(
    ignore_urls=[
        r&quot;.*google-analytics.*&quot;,
        r&quot;.*googletagmanager.*&quot;,
        r&quot;.*hotjar.*&quot;,
        r&quot;.*segment.*&quot;
    ]
)
</code></pre>
    <hr />
    <h2 id="hands-on-exercise-implementing-custom-stability-check">ğŸ”§ Hands-On Exercise: Implementing Custom Stability
        Check</h2>
    <p>Create a test that demonstrates Waitless in action:</p>
    <pre><code class="language-python">from selenium import webdriver
from selenium.webdriver.common.by import By
from waitless import stabilize, StabilityConfig, get_diagnostics
import time

# Setup with custom config
config = StabilityConfig(
    mutation_settle_time=200,  # Extra buffer for this exercise
    max_wait_time=10000
)

driver = stabilize(webdriver.Chrome(), config=config)

try:
    # Test 1: Dynamic content loading
    driver.get(&quot;https://jsonplaceholder.typicode.com/&quot;)

    # By the time this line runs, the page is guaranteed stable
    title = driver.find_element(By.TAG_NAME, &quot;h1&quot;).text
    print(f&quot;âœ“ Page loaded. Title: {title}&quot;)

    # Check what Waitless detected
    diagnostics = get_diagnostics(driver)
    print(f&quot;  Stability achieved in {diagnostics['total_wait_time']}ms&quot;)

    # Test 2: Navigating to a different page
    driver.get(&quot;https://httpbin.org/html&quot;)
    content = driver.find_element(By.TAG_NAME, &quot;p&quot;).text[:50]
    print(f&quot;âœ“ Second page loaded. Content preview: {content}...&quot;)

    print(&quot;\nâœ… All tests passed with automatic stability detection!&quot;)

finally:
    driver.quit()
</code></pre>
    <hr />
    <h2 id="chapter-3-summary">ğŸ“‹ Chapter 3 Summary</h2>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Benefit</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Automatic stability detection</td>
                <td>No manual waits needed</td>
            </tr>
            <tr>
                <td>DOM mutation tracking</td>
                <td>Catches React/Vue re-renders</td>
            </tr>
            <tr>
                <td>Network request tracking</td>
                <td>Waits for AJAX to complete</td>
            </tr>
            <tr>
                <td>Animation awareness</td>
                <td>Prevents mid-animation clicks</td>
            </tr>
            <tr>
                <td>Zero code changes</td>
                <td>Works with existing tests</td>
            </tr>
            <tr>
                <td>Configurable thresholds</td>
                <td>Tune for your app's behavior</td>
            </tr>
        </tbody>
    </table>
    <p><strong>Key Takeaway:</strong> Waitless shifts the waiting logic from your tests to the browser itself. Instead
        of guessing when to wait, it observes actual browser activity and proceeds only when truly stable.</p>
    <p><strong>Coming up next:</strong> Now that we've eliminated flakiness in functional tests, let's tackle visual
        testingâ€”because a button working isn't the same as a button looking right.</p>
    <hr />
    <h1 id="part-ii-visual-testing">PART II: VISUAL TESTING</h1>
    <h2 id="catching-what-functional-tests-miss">Catching What Functional Tests Miss</h2>
    <blockquote>
        <p><em>"A user doesn't interact with the DOMâ€”they interact with pixels. Test accordingly."</em></p>
    </blockquote>
    <hr />
    <h1 id="chapter-4-visual-guard-comprehensive-visual-regression-testing">Chapter 4: Visual Guard - Comprehensive
        Visual Regression Testing</h1>
    <h2 id="why-visual-testing-matters">Why Visual Testing Matters</h2>
    <p>Functional tests verify that buttons click and forms submit. They <strong>don't</strong> verify that:
        - The button is visible and properly styled
        - Text is readable (not white on white)
        - Layout hasn't shifted unexpectedly
        - Mobile responsive design still works
        - CSS didn't accidentally hide critical elements</p>
    <p>A user sees pixels, not DOM elements. Visual testing validates what users actually experience.</p>
    <h3 id="the-real-world-cost-of-missed-visual-bugs">The Real-World Cost of Missed Visual Bugs</h3>
    <table>
        <thead>
            <tr>
                <th>Bug Type</th>
                <th>Functional Test Result</th>
                <th>User Experience</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Button moved 200px left</td>
                <td>âœ… PASS (still clickable)</td>
                <td>"Where's the buy button?"</td>
            </tr>
            <tr>
                <td>Text color matches background</td>
                <td>âœ… PASS (text exists in DOM)</td>
                <td>"I can't read anything!"</td>
            </tr>
            <tr>
                <td>Modal renders behind overlay</td>
                <td>âœ… PASS (elements exist)</td>
                <td>"The site is frozen!"</td>
            </tr>
            <tr>
                <td>Font failed to load</td>
                <td>âœ… PASS (text displays)</td>
                <td>"This looks unprofessional"</td>
            </tr>
            <tr>
                <td>Mobile layout broken</td>
                <td>âœ… PASS (desktop tested)</td>
                <td>50% of users can't use site</td>
            </tr>
        </tbody>
    </table>
    <hr />
    <h2 id="the-limitation-of-pixel-perfect-comparison">The Limitation of Pixel-Perfect Comparison</h2>
    <p>Traditional visual testing compares screenshots pixel-by-pixel:</p>
    <pre><code class="language-python"># Naive approach
from PIL import ImageChops

def compare_images(baseline, current):
    diff = ImageChops.difference(baseline, current)
    return diff.getbbox() is None  # True if identical
</code></pre>
    <p><strong>Problems with this approach:</strong>
        - Anti-aliasing differences across browsers/OS
        - Sub-pixel rendering variations
        - Font smoothing differences (Mac vs Windows)
        - System clock visible in screenshots
        - Dynamic content (usernames, timestamps)
        - <strong>Result: Constant false positives</strong></p>
    <h3 id="key-insight-identical-pixels-same-visual-experience">ğŸ’¡ Key Insight: Identical Pixels â‰  Same Visual
        Experience</h3>
    <p>Two images can be:
        - <strong>Pixel-different but visually identical</strong> (anti-aliasing variations)
        - <strong>Pixel-similar but visually different</strong> (subtle color shift across entire page)</p>
    <p>We need algorithms that match <strong>human perception</strong>, not bit comparison.</p>
    <hr />
    <h2 id="visual-guards-intelligent-approach">Visual Guard's Intelligent Approach</h2>
    <p>Visual Guard uses <strong>perceptual comparison algorithms</strong> that mimic how humans see:</p>
    <h3 id="algorithm-1-ssim-structural-similarity-index">Algorithm 1: SSIM (Structural Similarity Index)</h3>
    <p>SSIM doesn't compare pixelsâ€”it compares the <strong>structure</strong> of images:</p>
    <pre><code>SSIM analyzes three components:
1. Luminance (l) - Overall brightness comparison
2. Contrast (c) - Variation in brightness
3. Structure (s) - Patterns and edges

Final Score = l^Î± Ã— c^Î² Ã— s^Î³
Where Î±, Î², Î³ are weights (typically all 1)
</code></pre>
    <p><strong>ğŸ” Deep Dive: How SSIM Works</strong></p>
    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SSIM COMPARISON PROCESS                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  BASELINE IMAGE              CURRENT IMAGE                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ â”‚         â”‚ â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ â”‚                â”‚
â”‚  â”‚ â–‘â–‘â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘ â”‚         â”‚ â–‘â–‘â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘ â”‚                â”‚
â”‚  â”‚ â–‘â–‘â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘ â”‚         â”‚ â–‘â–‘â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘ â”‚                â”‚
â”‚  â”‚ â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ â”‚         â”‚ â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚           â”‚                          â”‚                          â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                      â–¼                                          â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                 â”‚
â”‚         â”‚  For each window:   â”‚                                 â”‚
â”‚         â”‚  â€¢ Mean (Î¼)         â”‚                                 â”‚
â”‚         â”‚  â€¢ Variance (ÏƒÂ²)    â”‚                                 â”‚
â”‚         â”‚  â€¢ Covariance (Ïƒxy) â”‚                                 â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                 â”‚
â”‚                      â”‚                                          â”‚
â”‚                      â–¼                                          â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                 â”‚
â”‚         â”‚  Calculate SSIM:    â”‚                                 â”‚
â”‚         â”‚  (2Î¼xÎ¼y + C1)(2Ïƒxy + C2)                              â”‚
â”‚         â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                            â”‚
â”‚         â”‚  (Î¼xÂ² + Î¼yÂ² + C1)(ÏƒxÂ² + ÏƒyÂ² + C2)                     â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                 â”‚
â”‚                      â”‚                                          â”‚
â”‚                      â–¼                                          â”‚
â”‚              SSIM Score: 0.97                                   â”‚
â”‚              (1.0 = identical, 0.0 = completely different)      â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
    <p><strong>Why SSIM is better for visual testing:</strong>
        - Ignores minor anti-aliasing differences (structure preserved)
        - Detects layout shifts (structure changed)
        - Handles slight color variations gracefully
        - Matches human perception of "same" vs "different"</p>
    <h3 id="algorithm-2-perceptual-hashing-phash">Algorithm 2: Perceptual Hashing (pHash)</h3>
    <p>pHash creates a "fingerprint" of the image that's resistant to minor changes:</p>
    <pre><code class="language-python"># How pHash works conceptually
def perceptual_hash(image):
    # 1. Resize to small square (32x32)
    small = resize(image, 32, 32)

    # 2. Convert to grayscale
    gray = grayscale(small)

    # 3. Apply Discrete Cosine Transform (DCT)
    dct = discrete_cosine_transform(gray)

    # 4. Keep only low-frequency components (top-left 8x8)
    low_freq = dct[:8, :8]

    # 5. Compute average (excluding DC component)
    avg = average(low_freq[1:])

    # 6. Create hash: 1 if above average, 0 if below
    hash = &quot;&quot;.join(&quot;1&quot; if v &gt; avg else &quot;0&quot; for v in low_freq.flat)

    return hash  # 64-bit string like &quot;1010110010...&quot;
</code></pre>
    <p><strong>Comparing with pHash:</strong></p>
    <pre><code class="language-python"># Hamming distance = number of different bits
hash1 = &quot;10101100...&quot;  # Baseline
hash2 = &quot;10101110...&quot;  # Current (only 1 bit different)

hamming_distance = 1  # Very similar!

# Threshold: distance &lt; 10 means same image
</code></pre>
    <hr />
    <h2 id="using-visual-guard">Using Visual Guard</h2>
    <h3 id="installation">Installation</h3>
    <pre><code class="language-bash">pip install visual-guard
</code></pre>
    <h3 id="basic-usage">Basic Usage</h3>
    <pre><code class="language-python">from selenium import webdriver
from visualguard import VisualGuard

driver = webdriver.Chrome()
driver.get(&quot;https://example.com&quot;)

# Initialize Visual Guard
guard = VisualGuard(
    baseline_dir=&quot;./baselines&quot;,
    comparison_method=&quot;ssim&quot;,
    threshold=0.95  # 95% similarity required to pass
)

# Capture current state
guard.capture(&quot;homepage&quot;, driver)

# Compare against baseline (creates baseline if first run)
result = guard.compare(&quot;homepage&quot;)

if not result.passed:
    print(f&quot;Visual regression detected!&quot;)
    print(f&quot;Similarity score: {result.similarity:.2%}&quot;)
    print(f&quot;Difference regions: {result.diff_regions}&quot;)
    result.save_diff_image(&quot;./reports/homepage_diff.png&quot;)
else:
    print(f&quot;Visual check passed! Similarity: {result.similarity:.2%}&quot;)

driver.quit()
</code></pre>
    <h3 id="handling-dynamic-content">Handling Dynamic Content</h3>
    <p>Real applications have dynamic content: timestamps, usernames, advertisements. Visual Guard provides region
        masking:</p>
    <pre><code class="language-python">from visualguard import VisualGuard, MaskRegion

guard = VisualGuard(baseline_dir=&quot;./baselines&quot;)

# Define regions to ignore during comparison
masks = [
    # By coordinates (x, y, width, height)
    MaskRegion(name=&quot;header_time&quot;, x=800, y=10, width=150, height=30),

    # By CSS selector (element found and masked automatically)
    MaskRegion(name=&quot;user_avatar&quot;, selector=&quot;#user-avatar&quot;),
    MaskRegion(name=&quot;ad_banner&quot;, selector=&quot;.advertisement&quot;),
    MaskRegion(name=&quot;timestamp&quot;, selector=&quot;[data-testid='timestamp']&quot;),
]

result = guard.compare(&quot;dashboard&quot;, masks=masks)
</code></pre>
    <h3 id="dynamic-mask-discovery">Dynamic Mask Discovery</h3>
    <p>Don't know what's dynamic? Let Visual Guard figure it out:</p>
    <pre><code class="language-python">from visualguard import discover_dynamic_regions

# Load the same page 3 times, detect what changes
dynamic_regions = discover_dynamic_regions(
    driver,
    url=&quot;https://app.example.com/dashboard&quot;,
    runs=3,
    interval_seconds=2
)

print(f&quot;Detected {len(dynamic_regions)} dynamic regions:&quot;)
for region in dynamic_regions:
    print(f&quot;  {region.selector}: changes {region.change_frequency}% of the time&quot;)

# Output:
# Detected 3 dynamic regions:
#   #notification-count: changes 100% of the time
#   .timestamp: changes 100% of the time
#   .chart-tooltip: changes 67% of the time
</code></pre>
    <hr />
    <h2 id="multi-browser-and-responsive-testing">Multi-Browser and Responsive Testing</h2>
    <h3 id="cross-browser-visual-tests">Cross-Browser Visual Tests</h3>
    <pre><code class="language-python">from visualguard import VisualGuard, BrowserConfig

# Define all browser/viewport combinations to test
configurations = [
    # Desktop browsers
    BrowserConfig(browser=&quot;chrome&quot;, width=1920, height=1080),
    BrowserConfig(browser=&quot;firefox&quot;, width=1920, height=1080),
    BrowserConfig(browser=&quot;edge&quot;, width=1920, height=1080),

    # Mobile viewports (using Chrome)
    BrowserConfig(browser=&quot;chrome&quot;, width=375, height=812, device=&quot;iPhone 12&quot;),
    BrowserConfig(browser=&quot;chrome&quot;, width=414, height=896, device=&quot;iPhone 11&quot;),
    BrowserConfig(browser=&quot;chrome&quot;, width=768, height=1024, device=&quot;iPad&quot;),
]

guard = VisualGuard(baseline_dir=&quot;./baselines/multi-browser&quot;)

for config in configurations:
    driver = create_driver_for_config(config)
    driver.get(&quot;https://example.com&quot;)

    # Each config gets its own baseline
    capture_name = f&quot;homepage_{config.browser}_{config.width}x{config.height}&quot;
    guard.capture(capture_name, driver)
    result = guard.compare(capture_name)

    print(f&quot;{capture_name}: {'PASS' if result.passed else 'FAIL'}&quot;)
    driver.quit()
</code></pre>
    <h3 id="full-page-screenshots">Full-Page Screenshots</h3>
    <p>For pages with scroll:</p>
    <pre><code class="language-python">from visualguard import VisualGuard, FullPageMode

guard = VisualGuard(
    baseline_dir=&quot;./baselines&quot;,
    full_page_mode=FullPageMode.SCROLL_STITCH  # Scroll and stitch screenshots
)

# Captures entire page, not just viewport
guard.capture(&quot;long_page&quot;, driver)
</code></pre>
    <hr />
    <h2 id="html-report-generation">HTML Report Generation</h2>
    <pre><code class="language-python">from visualguard import generate_report

# After running all visual tests
generate_report(
    results_dir=&quot;./visual_results&quot;,
    output_file=&quot;./reports/visual_regression.html&quot;,
    include_thumbnails=True,
    side_by_side=True,
    diff_highlighting=True
)
</code></pre>
    <p><strong>The report includes:</strong>
        - Thumbnail grid of all comparisons
        - Side-by-side baseline vs. current
        - Difference highlighting overlay (pink/red shows changes)
        - Filtering by status (passed/failed)
        - One-click baseline update for intentional changes</p>
    <hr />
    <h2 id="hands-on-exercise-visual-testing-workflow">ğŸ”§ Hands-On Exercise: Visual Testing Workflow</h2>
    <pre><code class="language-python">&quot;&quot;&quot;
Complete visual testing workflow example.
Creates baselines on first run, compares on subsequent runs.
&quot;&quot;&quot;
from selenium import webdriver
from visualguard import VisualGuard, MaskRegion
import os

def run_visual_tests():
    driver = webdriver.Chrome()
    guard = VisualGuard(baseline_dir=&quot;./baselines&quot;, threshold=0.95)

    test_cases = [
        {
            &quot;name&quot;: &quot;google_homepage&quot;,
            &quot;url&quot;: &quot;https://www.google.com&quot;,
            &quot;masks&quot;: [
                MaskRegion(name=&quot;doodle&quot;, selector=&quot;.lnXdpd&quot;),  # Google Doodle changes
            ]
        },
        {
            &quot;name&quot;: &quot;example_domain&quot;,
            &quot;url&quot;: &quot;https://example.com&quot;,
            &quot;masks&quot;: []
        }
    ]

    results = []

    for test in test_cases:
        driver.get(test[&quot;url&quot;])

        # Wait for page to stabilize
        import time
        time.sleep(2)

        # Capture
        guard.capture(test[&quot;name&quot;], driver)

        # Compare
        result = guard.compare(test[&quot;name&quot;], masks=test[&quot;masks&quot;])
        results.append({
            &quot;name&quot;: test[&quot;name&quot;],
            &quot;passed&quot;: result.passed,
            &quot;similarity&quot;: result.similarity
        })

        # Save diff image if failed
        if not result.passed:
            os.makedirs(&quot;./diffs&quot;, exist_ok=True)
            result.save_diff_image(f&quot;./diffs/{test['name']}_diff.png&quot;)

    driver.quit()

    # Print summary
    print(&quot;\n&quot; + &quot;=&quot;*50)
    print(&quot;VISUAL TEST RESULTS&quot;)
    print(&quot;=&quot;*50)
    for r in results:
        status = &quot;âœ… PASS&quot; if r[&quot;passed&quot;] else &quot;âŒ FAIL&quot;
        print(f&quot;{status} | {r['name']} | Similarity: {r['similarity']:.2%}&quot;)

    passed = sum(1 for r in results if r[&quot;passed&quot;])
    print(f&quot;\nTotal: {passed}/{len(results)} passed&quot;)

if __name__ == &quot;__main__&quot;:
    run_visual_tests()
</code></pre>
    <hr />
    <h2 id="chapter-4-summary">ğŸ“‹ Chapter 4 Summary</h2>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Key Takeaway</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Functional vs Visual</td>
                <td>Functional tests miss layout/style bugs</td>
            </tr>
            <tr>
                <td>Pixel comparison</td>
                <td>Too brittle, constant false positives</td>
            </tr>
            <tr>
                <td>SSIM</td>
                <td>Compares structure, matches human perception</td>
            </tr>
            <tr>
                <td>pHash</td>
                <td>Creates fingerprint, tolerates minor changes</td>
            </tr>
            <tr>
                <td>Region masking</td>
                <td>Handle dynamic content areas</td>
            </tr>
            <tr>
                <td>Multi-browser</td>
                <td>Test across browsers and viewports</td>
            </tr>
        </tbody>
    </table>
    <hr />
    <h1 id="part-iii-authentication-optimization">PART III: AUTHENTICATION OPTIMIZATION</h1>
    <h2 id="the-fastest-login-is-no-login-at-all">The Fastest Login Is No Login At All</h2>
    <blockquote>
        <p><em>"Every second spent logging in is a second not spent testing."</em></p>
    </blockquote>
    <hr />
    <h1 id="chapter-5-the-hidden-cost-of-authentication">Chapter 5: The Hidden Cost of Authentication</h1>
    <h2 id="the-40-tax-on-test-execution">The 40% Tax on Test Execution</h2>
    <p>Authentication in enterprise applications typically involves:
        1. Loading the login page
        2. Entering credentials
        3. Submitting the form
        4. Waiting for MFA/2FA (if applicable)
        5. Handling redirects
        6. Waiting for dashboard to load</p>
    <p><strong>Average time: 8-15 seconds per login.</strong></p>
    <p>For a test suite with 500 tests, each starting with a fresh login:
        - 500 tests Ã— 10 seconds = <strong>83 minutes</strong> just on authentication
        - That's 23% of a 6-hour test run spent logging in</p>
    <h3 id="the-deeper-problem-test-isolation-requirements">The Deeper Problem: Test Isolation Requirements</h3>
    <p>Best practices dictate that tests should be isolated. Each test should:
        - Start from a known state
        - Not depend on previous tests
        - Clean up after itself</p>
    <p>This usually means: <strong>fresh browser session per test = login per test.</strong></p>
    <hr />
    <h2 id="understanding-browser-authentication-state">Understanding Browser Authentication State</h2>
    <p>Before we can skip login, we need to understand what "being logged in" means at a technical level.</p>
    <h3 id="deep-dive-what-happens-when-you-log-in">ğŸ” Deep Dive: What Happens When You Log In</h3>
    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LOGIN PROCESS BREAKDOWN                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚ 1. USER SUBMITS CREDENTIALS                                     â”‚
â”‚    POST /auth/login                                              â”‚
â”‚    Body: { username: &quot;user@example.com&quot;, password: &quot;***&quot; }      â”‚
â”‚                                                                  â”‚
â”‚ 2. SERVER VALIDATES &amp; GENERATES SESSION                         â”‚
â”‚    â€¢ Checks credentials against database                         â”‚
â”‚    â€¢ Creates session record (server-side)                       â”‚
â”‚    â€¢ Generates tokens (JWT, session ID, etc.)                   â”‚
â”‚                                                                  â”‚
â”‚ 3. SERVER SENDS AUTHENTICATION DATA TO BROWSER                  â”‚
â”‚    Set-Cookie: session_id=abc123; HttpOnly; Secure              â”‚
â”‚    Set-Cookie: csrf_token=xyz789; SameSite=Strict               â”‚
â”‚    Response: { access_token: &quot;eyJ...&quot;, user: {...} }            â”‚
â”‚                                                                  â”‚
â”‚ 4. BROWSER STORES AUTHENTICATION DATA                           â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚    â”‚ COOKIES        â”‚ SESSION STORAGE â”‚ LOCAL STORAGE    â”‚      â”‚
â”‚    â”‚ session_id     â”‚ temp_data       â”‚ user_settings    â”‚      â”‚
â”‚    â”‚ csrf_token     â”‚ form_state      â”‚ access_token     â”‚      â”‚
â”‚    â”‚ remember_me    â”‚                 â”‚ refresh_token    â”‚      â”‚
â”‚    â”‚ preferences    â”‚                 â”‚ user_profile     â”‚      â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                                  â”‚
â”‚ 5. SUBSEQUENT REQUESTS INCLUDE AUTH DATA                        â”‚
â”‚    Cookie: session_id=abc123; csrf_token=xyz789                 â”‚
â”‚    Authorization: Bearer eyJ...                                  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
    <h3 id="the-four-types-of-browser-state">The Four Types of Browser State</h3>
    <table>
        <thead>
            <tr>
                <th>Storage Type</th>
                <th>Persists After Close?</th>
                <th>Accessible By</th>
                <th>Size Limit</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Cookies</strong></td>
                <td>Depends on <code>Expires</code></td>
                <td>Server + JavaScript</td>
                <td>~4KB per cookie</td>
            </tr>
            <tr>
                <td><strong>LocalStorage</strong></td>
                <td>Yes</td>
                <td>JavaScript only</td>
                <td>~5MB</td>
            </tr>
            <tr>
                <td><strong>SessionStorage</strong></td>
                <td>No (tab-scoped)</td>
                <td>JavaScript only</td>
                <td>~5MB</td>
            </tr>
            <tr>
                <td><strong>IndexedDB</strong></td>
                <td>Yes</td>
                <td>JavaScript only</td>
                <td>Varies (large)</td>
            </tr>
        </tbody>
    </table>
    <p><strong>Key Insight:</strong> Different apps store auth tokens in different places. Some use cookies, some use
        localStorage, some use both.</p>
    <hr />
    <h2 id="traditional-approaches-and-their-limits">Traditional Approaches and Their Limits</h2>
    <h3 id="approach-1-shared-session-anti-pattern">Approach 1: Shared Session (Anti-Pattern)</h3>
    <pre><code class="language-python"># DON'T DO THIS
@pytest.fixture(scope=&quot;session&quot;)
def authenticated_driver():
    driver = webdriver.Chrome()
    login(driver)
    yield driver
    driver.quit()
</code></pre>
    <p><strong>Problems:</strong>
        - Tests aren't isolated
        - One test's actions affect subsequent tests
        - Cookie expiration causes cascading failures
        - State pollution is hard to debug</p>
    <h3 id="approach-2-api-token-injection">Approach 2: API Token Injection</h3>
    <pre><code class="language-python">def fast_login(driver, username, password):
    # Get auth token via API (bypasses UI)
    response = requests.post(
        &quot;https://api.example.com/auth/login&quot;,
        json={&quot;username&quot;: username, &quot;password&quot;: password}
    )
    token = response.json()[&quot;token&quot;]

    # Navigate first (required for cookie domain)
    driver.get(&quot;https://app.example.com&quot;)

    # Set cookie
    driver.add_cookie({
        &quot;name&quot;: &quot;auth_token&quot;,
        &quot;value&quot;: token,
        &quot;domain&quot;: &quot;app.example.com&quot;
    })

    driver.refresh()
</code></pre>
    <p><strong>Improvements:</strong>
        - Much faster than UI login
        - Bypasses MFA in some cases</p>
    <p><strong>Remaining Problems:</strong>
        - Only works if API endpoint exists and is accessible
        - Single cookie may not be enough (CSRF tokens, etc.)
        - LocalStorage/SessionStorage not populated
        - Application-specific initialization not triggered</p>
    <hr />
    <h1 id="chapter-6-selenium-teleport-complete-browser-state-restoration">Chapter 6: Selenium Teleport - Complete
        Browser State Restoration</h1>
    <h2 id="the-teleportation-pattern">The Teleportation Pattern</h2>
    <p><strong>Selenium Teleport</strong> captures the <strong>complete browser state</strong> after a successful login
        and restores it instantly in future sessions.</p>
    <h3 id="what-gets-captured">What Gets Captured</h3>
    <pre><code class="language-python">{
    &quot;captured_at&quot;: &quot;2024-06-15T10:30:00Z&quot;,
    &quot;url&quot;: &quot;https://app.example.com/dashboard&quot;,

    &quot;cookies&quot;: [
        {&quot;name&quot;: &quot;session_id&quot;, &quot;value&quot;: &quot;abc123&quot;, &quot;domain&quot;: &quot;.example.com&quot;, ...},
        {&quot;name&quot;: &quot;csrf_token&quot;, &quot;value&quot;: &quot;xyz789&quot;, &quot;domain&quot;: &quot;app.example.com&quot;, ...},
        {&quot;name&quot;: &quot;_ga&quot;, &quot;value&quot;: &quot;GA1.2...&quot;, &quot;domain&quot;: &quot;.example.com&quot;, ...}
    ],

    &quot;local_storage&quot;: {
        &quot;user_profile&quot;: &quot;{\&quot;id\&quot;: 123, \&quot;name\&quot;: \&quot;Test User\&quot;}&quot;,
        &quot;access_token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot;,
        &quot;app_settings&quot;: &quot;{\&quot;theme\&quot;: \&quot;dark\&quot;, \&quot;notifications\&quot;: true}&quot;
    },

    &quot;session_storage&quot;: {
        &quot;current_page_state&quot;: &quot;{\&quot;tab\&quot;: \&quot;dashboard\&quot;, \&quot;filters\&quot;: []}&quot;,
        &quot;form_draft&quot;: null
    }
}
</code></pre>
    <hr />
    <h2 id="installation-and-setup">Installation and Setup</h2>
    <pre><code class="language-bash">pip install selenium-teleport
</code></pre>
    <h3 id="state-capture-workflow">State Capture Workflow</h3>
    <pre><code class="language-python">from selenium import webdriver
from selenium_teleport import BrowserState

# Step 1: Perform login (one-time setup)
driver = webdriver.Chrome()
driver.get(&quot;https://app.example.com/login&quot;)

# Option A: Manual login
input(&quot;Log in manually, then press Enter...&quot;)

# Option B: Automated login
driver.find_element(By.ID, &quot;email&quot;).send_keys(&quot;user@example.com&quot;)
driver.find_element(By.ID, &quot;password&quot;).send_keys(&quot;secure_password&quot;)
driver.find_element(By.ID, &quot;login-btn&quot;).click()

# Wait for complete authentication
WebDriverWait(driver, 30).until(
    EC.presence_of_element_located((By.ID, &quot;dashboard&quot;))
)

# Step 2: Capture the authenticated state
state = BrowserState.capture(driver)

# Step 3: Save to file for reuse
state.save(&quot;./states/admin_user.json&quot;)

print(f&quot;âœ“ Captured {len(state.cookies)} cookies&quot;)
print(f&quot;âœ“ Captured {len(state.local_storage)} localStorage items&quot;)
print(f&quot;âœ“ Captured {len(state.session_storage)} sessionStorage items&quot;)

driver.quit()
</code></pre>
    <h3 id="state-restoration-in-tests">State Restoration in Tests</h3>
    <pre><code class="language-python">from selenium import webdriver
from selenium_teleport import BrowserState

@pytest.fixture
def authenticated_driver():
    driver = webdriver.Chrome()

    # CRITICAL: Navigate to the domain first
    # Browsers enforce Same-Origin Policy for cookies
    driver.get(&quot;https://app.example.com&quot;)

    # Restore the captured state
    state = BrowserState.load(&quot;./states/admin_user.json&quot;)
    state.restore(driver)

    # Refresh to apply state
    driver.refresh()

    yield driver
    driver.quit()

def test_dashboard_loads(authenticated_driver):
    # Already logged in! No login steps needed
    assert &quot;Dashboard&quot; in authenticated_driver.title

def test_user_can_view_settings(authenticated_driver):
    authenticated_driver.get(&quot;https://app.example.com/settings&quot;)
    assert authenticated_driver.find_element(By.ID, &quot;settings-form&quot;).is_displayed()
</code></pre>
    <hr />
    <h2 id="deep-dive-handling-same-origin-policy">ğŸ” Deep Dive: Handling Same-Origin Policy</h2>
    <p>Browsers prevent setting cookies for domains you haven't visited. This is a security feature called the
        Same-Origin Policy.</p>
    <p><strong>The Problem:</strong></p>
    <pre><code class="language-python">driver = webdriver.Chrome()
# Current URL is about:blank

driver.add_cookie({&quot;name&quot;: &quot;token&quot;, &quot;value&quot;: &quot;abc&quot;, &quot;domain&quot;: &quot;app.example.com&quot;})
# Silently fails! No error, but cookie isn't set
</code></pre>
    <p><strong>Selenium Teleport's Solution:</strong></p>
    <pre><code class="language-python">def restore(self, driver):
    # Group cookies by domain
    domains = set(c[&quot;domain&quot;] for c in self.cookies)

    for domain in domains:
        # Navigate to each domain first
        clean_domain = domain.lstrip(&quot;.&quot;)
        driver.get(f&quot;https://{clean_domain}&quot;)

        # Now cookies for this domain can be set
        domain_cookies = [c for c in self.cookies if c[&quot;domain&quot;] == domain]
        for cookie in domain_cookies:
            try:
                # Remove unsupported keys that Selenium doesn't accept
                safe_cookie = {k: v for k, v in cookie.items() 
                               if k in [&quot;name&quot;, &quot;value&quot;, &quot;domain&quot;, &quot;path&quot;, 
                                        &quot;secure&quot;, &quot;httpOnly&quot;, &quot;expiry&quot;, &quot;sameSite&quot;]}
                driver.add_cookie(safe_cookie)
            except Exception as e:
                logging.warning(f&quot;Failed to set cookie {cookie['name']}: {e}&quot;)
</code></pre>
    <hr />
    <h2 id="multi-user-state-management">Multi-User State Management</h2>
    <p>For tests that need different user roles:</p>
    <pre><code class="language-python">from selenium_teleport import StateManager

# Setup: Capture states for different user roles
manager = StateManager(states_dir=&quot;./states&quot;)

# (Run once for each user type)
# manager.capture(&quot;admin_user&quot;, driver)
# manager.capture(&quot;standard_user&quot;, driver)
# manager.capture(&quot;readonly_user&quot;, driver)

# In tests: Parameterized fixture
@pytest.fixture(params=[&quot;admin_user&quot;, &quot;standard_user&quot;])
def user_driver(request):
    driver = webdriver.Chrome()
    driver.get(&quot;https://app.example.com&quot;)

    manager = StateManager(states_dir=&quot;./states&quot;)
    manager.restore(request.param, driver)
    driver.refresh()

    yield driver, request.param
    driver.quit()

def test_permission_based_access(user_driver):
    driver, user_type = user_driver

    # Navigate to admin page
    driver.get(&quot;https://app.example.com/admin&quot;)

    if user_type == &quot;admin_user&quot;:
        assert driver.find_element(By.ID, &quot;admin-panel&quot;).is_displayed()
    else:
        # Standard users should see &quot;Access Denied&quot;
        assert &quot;Access Denied&quot; in driver.page_source
</code></pre>
    <hr />
    <h2 id="state-freshness-and-expiration">State Freshness and Expiration</h2>
    <p>States don't last foreverâ€”sessions expire, tokens become invalid.</p>
    <pre><code class="language-python">from selenium_teleport import BrowserState
from datetime import datetime, timedelta

state = BrowserState.load(&quot;./states/admin_user.json&quot;)

# Check if state is stale
if state.captured_at &lt; datetime.now() - timedelta(hours=24):
    print(&quot;âš ï¸ State is more than 24 hours old - may need refresh&quot;)

# Check for expired cookies
expired = [
    c[&quot;name&quot;] for c in state.cookies 
    if c.get(&quot;expiry&quot;) and c[&quot;expiry&quot;] &lt; datetime.now().timestamp()
]
if expired:
    print(f&quot;âš ï¸ These cookies have expired: {expired}&quot;)

# Automatic freshness check during restore
try:
    state.restore(driver, strict=True)  # Raises if any cookie expired
except StateExpiredError as e:
    print(f&quot;State invalid: {e}&quot;)
    # Re-authenticate and capture new state
</code></pre>
    <h3 id="cicd-integration-auto-refresh-pattern">CI/CD Integration: Auto-Refresh Pattern</h3>
    <pre><code class="language-yaml"># .github/workflows/refresh-states.yml
name: Refresh Auth States

on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:  # Manual trigger

jobs:
  refresh:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Refresh admin state
        run: python scripts/refresh_states.py

      - name: Upload new states
        uses: actions/upload-artifact@v4
        with:
          name: auth-states
          path: states/
</code></pre>
    <hr />
    <h2 id="performance-impact">Performance Impact</h2>
    <table>
        <thead>
            <tr>
                <th>Scenario</th>
                <th>Time Per Test</th>
                <th>For 500 Tests</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Full UI Login</td>
                <td>10-15s</td>
                <td>83+ minutes</td>
            </tr>
            <tr>
                <td>API Token + Cookie</td>
                <td>3-5s</td>
                <td>25-40 minutes</td>
            </tr>
            <tr>
                <td>Selenium Teleport</td>
                <td><strong>0.5-1s</strong></td>
                <td><strong>4-8 minutes</strong></td>
            </tr>
        </tbody>
    </table>
    <p><strong>Total time saved per CI run: 75+ minutes</strong></p>
    <p>For a team running CI 10 times/day: <strong>750 minutes (12.5 hours) saved daily</strong></p>
    <hr />
    <h2 id="common-pitfalls_1">âš ï¸ Common Pitfalls</h2>
    <h3 id="pitfall-1-httponly-cookies">Pitfall 1: HttpOnly Cookies</h3>
    <p>Cookies marked <code>HttpOnly</code> can't be read by JavaScript, but CAN be set via Selenium.</p>
    <pre><code class="language-python"># This works even for HttpOnly cookies
driver.add_cookie({
    &quot;name&quot;: &quot;session&quot;,
    &quot;value&quot;: &quot;abc123&quot;,
    &quot;httpOnly&quot;: True  # Selenium can still set this
})
</code></pre>
    <h3 id="pitfall-2-secure-cookies-on-http">Pitfall 2: Secure Cookies on HTTP</h3>
    <p><code>Secure</code> cookies only work on HTTPS:</p>
    <pre><code class="language-python"># âŒ WRONG: HTTP won't accept Secure cookies
driver.get(&quot;http://app.example.com&quot;)
driver.add_cookie({&quot;name&quot;: &quot;token&quot;, &quot;secure&quot;: True})  # Silently fails

# âœ… CORRECT: Use HTTPS
driver.get(&quot;https://app.example.com&quot;)
driver.add_cookie({&quot;name&quot;: &quot;token&quot;, &quot;secure&quot;: True})  # Works
</code></pre>
    <h3 id="pitfall-3-samesite-cookies">Pitfall 3: SameSite Cookies</h3>
    <p>Modern browsers enforce <code>SameSite</code> attribute:</p>
    <pre><code class="language-python"># SameSite=Strict cookies won't be sent on cross-site navigation
# Make sure you're on the correct domain when setting

driver.get(&quot;https://app.example.com&quot;)  # Navigate to same site
driver.add_cookie({
    &quot;name&quot;: &quot;csrf&quot;,
    &quot;value&quot;: &quot;token123&quot;,
    &quot;sameSite&quot;: &quot;Strict&quot;
})
</code></pre>
    <hr />
    <h2 id="hands-on-exercise-complete-teleport-workflow">ğŸ”§ Hands-On Exercise: Complete Teleport Workflow</h2>
    <pre><code class="language-python">&quot;&quot;&quot;
Complete Selenium Teleport workflow.
Run this once to capture state, then use in tests.
&quot;&quot;&quot;
from selenium import webdriver
from selenium_teleport import BrowserState, StateManager
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import os

def capture_state_demo():
    &quot;&quot;&quot;Demo: Capture state from Google (no login, just session)&quot;&quot;&quot;
    driver = webdriver.Chrome()
    driver.get(&quot;https://www.google.com&quot;)

    # Interact to generate some state
    search_box = driver.find_element(By.NAME, &quot;q&quot;)
    search_box.send_keys(&quot;Selenium Teleport&quot;)
    search_box.submit()

    # Wait for results
    WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.ID, &quot;search&quot;))
    )

    # Capture state
    state = BrowserState.capture(driver)

    # Save
    os.makedirs(&quot;./demo_states&quot;, exist_ok=True)
    state.save(&quot;./demo_states/google_session.json&quot;)

    print(f&quot;âœ“ Captured state from URL: {driver.current_url}&quot;)
    print(f&quot;  Cookies: {len(state.cookies)}&quot;)
    print(f&quot;  LocalStorage items: {len(state.local_storage)}&quot;)

    driver.quit()
    return state

def restore_state_demo():
    &quot;&quot;&quot;Demo: Restore the captured state&quot;&quot;&quot;
    driver = webdriver.Chrome()

    # Must navigate to domain first
    driver.get(&quot;https://www.google.com&quot;)

    # Load and restore state
    state = BrowserState.load(&quot;./demo_states/google_session.json&quot;)
    state.restore(driver)

    # Verify restoration
    cookies_count = len(driver.get_cookies())
    print(f&quot;âœ“ Restored {cookies_count} cookies&quot;)

    driver.quit()

if __name__ == &quot;__main__&quot;:
    print(&quot;Step 1: Capturing state...&quot;)
    capture_state_demo()

    print(&quot;\nStep 2: Restoring state...&quot;)
    restore_state_demo()

    print(&quot;\nâœ… Teleport demo complete!&quot;)
</code></pre>
    <hr />
    <h2 id="chapters-5-6-summary">ğŸ“‹ Chapters 5-6 Summary</h2>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Key Takeaway</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Auth Cost</td>
                <td>Login can consume 20-40% of test execution time</td>
            </tr>
            <tr>
                <td>Browser State</td>
                <td>Auth stored in cookies, localStorage, sessionStorage</td>
            </tr>
            <tr>
                <td>Same-Origin Policy</td>
                <td>Must navigate to domain before setting cookies</td>
            </tr>
            <tr>
                <td>Selenium Teleport</td>
                <td>Capture and restore complete auth state</td>
            </tr>
            <tr>
                <td>Multi-User</td>
                <td>Manage different user role states for comprehensive testing</td>
            </tr>
            <tr>
                <td>Freshness</td>
                <td>States expire; automate refresh in CI</td>
            </tr>
        </tbody>
    </table>
    <hr />
    <h1 id="part-iv-stealth-bot-evasion">PART IV: STEALTH &amp; BOT EVASION</h1>
    <p style="text-align: center; margin: 2rem 0;">
        <img src="/book/images/stealth.png" alt="Stealth Automation Techniques"
            style="max-width: 100%; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);" />
    </p>
    <h2 id="testing-behind-modern-security">Testing Behind Modern Security</h2>
    <blockquote>
        <p><em>"When the website thinks you're a bot, you can't test anything."</em></p>
    </blockquote>
    <hr />
    <h1 id="chapter-7-understanding-modern-bot-detection">Chapter 7: Understanding Modern Bot Detection</h1>
    <h2 id="why-your-tests-get-blocked">Why Your Tests Get Blocked</h2>
    <p>Modern bot detection has evolved far beyond simple CAPTCHAs. Services like Cloudflare, PerimeterX, DataDome, and
        Akamai use sophisticated fingerprinting that can detect standard Selenium in milliseconds.</p>
    <h3 id="the-detection-arsenal">The Detection Arsenal</h3>
    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   BOT DETECTION LAYERS                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  LAYER 1: BROWSER FINGERPRINT                                   â”‚
â”‚  Is this a real browser? Does it have all the expected APIs?    â”‚
â”‚  â€¢ navigator.webdriver flag                                      â”‚
â”‚  â€¢ WebGL renderer/vendor                                         â”‚
â”‚  â€¢ Canvas fingerprint                                            â”‚
â”‚  â€¢ Plugin list                                                   â”‚
â”‚  â€¢ Screen resolution consistency                                â”‚
â”‚                                                                  â”‚
â”‚  LAYER 2: BEHAVIORAL ANALYSIS                                   â”‚
â”‚  Does this user act human?                                      â”‚
â”‚  â€¢ Mouse movement patterns                                       â”‚
â”‚  â€¢ Keyboard timing                                               â”‚
â”‚  â€¢ Scroll behavior                                               â”‚
â”‚  â€¢ Time to first interaction                                    â”‚
â”‚                                                                  â”‚
â”‚  LAYER 3: NETWORK SIGNALS                                       â”‚
â”‚  Does the traffic look normal?                                  â”‚
â”‚  â€¢ IP reputation                                                 â”‚
â”‚  â€¢ TLS fingerprint (JA3)                                        â”‚
â”‚  â€¢ HTTP header order                                             â”‚
â”‚  â€¢ Request timing patterns                                       â”‚
â”‚                                                                  â”‚
â”‚  LAYER 4: CHALLENGE-RESPONSE                                    â”‚
â”‚  Can they solve puzzles?                                        â”‚
â”‚  â€¢ Invisible reCAPTCHA                                          â”‚
â”‚  â€¢ Cloudflare Turnstile                                         â”‚
â”‚  â€¢ Proof-of-work challenges                                     â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
    <hr />
    <h2 id="deep-dive-browser-fingerprinting">ğŸ” Deep Dive: Browser Fingerprinting</h2>
    <h3 id="detection-vector-1-the-webdriver-flag">Detection Vector 1: The WebDriver Flag</h3>
    <pre><code class="language-javascript">// What detection services check first
console.log(navigator.webdriver);  // true = Selenium!

// Standard Selenium Chrome sets this to true
// It's a W3C standard for automation detection
</code></pre>
    <p><strong>Why it exists:</strong> The WebDriver spec requires browsers to expose when they're being automated. This
        is a security feature, not a bug.</p>
    <h3 id="detection-vector-2-webgl-fingerprint">Detection Vector 2: WebGL Fingerprint</h3>
    <pre><code class="language-javascript">// Every GPU produces slightly different rendering
const canvas = document.createElement('canvas');
const gl = canvas.getContext('webgl');

const fingerprint = {
    vendor: gl.getParameter(gl.VENDOR),
    renderer: gl.getParameter(gl.RENDERER),
    extensions: gl.getSupportedExtensions()
};

// Real browser: &quot;Intel Inc.&quot; / &quot;Intel Iris OpenGL Engine&quot;
// Headless: Often &quot;Google SwiftShader&quot; or empty
</code></pre>
    <h3 id="detection-vector-3-canvas-fingerprint">Detection Vector 3: Canvas Fingerprint</h3>
    <pre><code class="language-javascript">// Same canvas operations produce different pixels per system
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

ctx.textBaseline = 'top';
ctx.font = '14px Arial';
ctx.fillText('fingerprint', 2, 2);

const hash = canvas.toDataURL().hashCode();
// Hash is unique per browser/OS/GPU combination
</code></pre>
    <h3 id="detection-vector-4-plugin-detection">Detection Vector 4: Plugin Detection</h3>
    <pre><code class="language-javascript">// Real browsers have plugins
console.log(navigator.plugins.length);
// Real Chrome: 3-5 plugins (PDF Viewer, etc.)
// Headless: 0 plugins

// Plugin details also checked
for (let plugin of navigator.plugins) {
    console.log(plugin.name, plugin.filename);
}
</code></pre>
    <h3 id="why-standard-selenium-fails">Why Standard Selenium Fails</h3>
    <pre><code class="language-python"># Standard Selenium Chrome instance
driver = webdriver.Chrome()

# Detection services see:
# âœ— navigator.webdriver = true
# âœ— No WebGL or suspicious WebGL
# âœ— No plugins
# âœ— Suspicious browser automation flags in Chrome args
# âœ— Inhuman interaction speed (clicks happen instantly)
# âœ— No mouse movement between clicks

# Result: Blocked immediately
</code></pre>
    <hr />
    <h2 id="detection-vector-5-behavioral-analysis">Detection Vector 5: Behavioral Analysis</h2>
    <p>Even if you fool the fingerprint checks, behavior gives you away:</p>
    <h3 id="mouse-movement">Mouse Movement</h3>
    <pre><code class="language-javascript">// Real users have natural mouse paths
document.addEventListener('mousemove', e =&gt; {
    recordMovement(e.clientX, e.clientY, Date.now());
});

// Analysis:
// Human: Curved paths, acceleration/deceleration, micro-movements
// Bot: No movements, or perfect straight lines between clicks
</code></pre>
    <h3 id="keyboard-timing">Keyboard Timing</h3>
    <pre><code class="language-javascript">// Real users have variable typing speed
document.addEventListener('keydown', e =&gt; {
    recordKeyTiming(e.key, Date.now());
});

// Analysis:
// Human: Variable delays (50-300ms), some keys faster (home row)
// Bot: Perfect consistent timing, or all keys instant
</code></pre>
    <h3 id="click-behavior">Click Behavior</h3>
    <table>
        <thead>
            <tr>
                <th>Metric</th>
                <th>Human</th>
                <th>Bot</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Time on page before first click</td>
                <td>2-10 seconds</td>
                <td>&lt; 500ms</td>
            </tr>
            <tr>
                <td>Mouse movement before click</td>
                <td>Curved path</td>
                <td>None or straight</td>
            </tr>
            <tr>
                <td>Click position</td>
                <td>Slightly random</td>
                <td>Exact center</td>
            </tr>
            <tr>
                <td>Double-click frequency</td>
                <td>Occasional</td>
                <td>Never or always</td>
            </tr>
        </tbody>
    </table>
    <hr />
    <h1 id="chapter-8-sb-stealth-wrapper-becoming-invisible">Chapter 8: SB Stealth Wrapper - Becoming Invisible</h1>
    <h2 id="architecture-of-stealth">ğŸ” Deep Dive: The Stealth Architecture</h2>
    <p><strong>SB Stealth Wrapper</strong> (StealthAutomation) builds on SeleniumBase to provide multi-layered stealth:
    </p>
    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    STEALTH ARCHITECTURE                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  LAYER 1: ENVIRONMENT DETECTION                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ â€¢ Detects CI vs Local development                        â”‚   â”‚
â”‚  â”‚ â€¢ Configures display (Xvfb on Linux headless)           â”‚   â”‚
â”‚  â”‚ â€¢ Sets appropriate headless mode                         â”‚   â”‚
â”‚  â”‚ â€¢ Handles Docker/container environments                  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚  LAYER 2: BROWSER FINGERPRINT SPOOFING                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ â€¢ Patches navigator.webdriver â†’ undefined                â”‚   â”‚
â”‚  â”‚ â€¢ Injects consistent WebGL fingerprint                   â”‚   â”‚
â”‚  â”‚ â€¢ Adds realistic plugins list                            â”‚   â”‚
â”‚  â”‚ â€¢ Consistent user-agent across all signals               â”‚   â”‚
â”‚  â”‚ â€¢ Spoofs hardware concurrency and device memory          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚  LAYER 3: HUMAN-LIKE BEHAVIOR                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ â€¢ Random micro-delays between actions                    â”‚   â”‚
â”‚  â”‚ â€¢ Simulated mouse movement paths                         â”‚   â”‚
â”‚  â”‚ â€¢ Realistic typing patterns with variable speed          â”‚   â”‚
â”‚  â”‚ â€¢ Random scroll behavior                                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚  LAYER 4: NETWORK NORMALIZATION                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ â€¢ Standard TLS configuration                             â”‚   â”‚
â”‚  â”‚ â€¢ Normal HTTP header ordering                            â”‚   â”‚
â”‚  â”‚ â€¢ Proxy rotation support                                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
    <hr />
    <h2 id="installation_1">Installation</h2>
    <pre><code class="language-bash">pip install stealthautomation
</code></pre>
    <h2 id="basic-usage_1">Basic Usage</h2>
    <pre><code class="language-python">from stealthautomation import StealthBrowser

# Automatic environment configuration
with StealthBrowser() as sb:
    # Navigate with human-like behavior
    sb.open(&quot;https://protected-site.com&quot;)

    # Interactions automatically include human patterns
    sb.type(&quot;#email&quot;, &quot;user@example.com&quot;)    # Types with realistic timing
    sb.type(&quot;#password&quot;, &quot;secret&quot;)
    sb.click(&quot;#login-button&quot;)                 # Includes mouse movement

    # Assertions work normally
    sb.assert_element(&quot;#dashboard&quot;)
</code></pre>
    <hr />
    <h2 id="configuration-options_1">Configuration Options</h2>
    <pre><code class="language-python">from stealthautomation import StealthBrowser, StealthConfig

config = StealthConfig(
    # Headless options
    headless=True,                    # True for CI, False for debugging
    headless_mode=&quot;new&quot;,              # Chrome's new headless (less detectable)

    # Display configuration (Linux CI)
    use_virtual_display=True,         # Use Xvfb
    display_width=1920,
    display_height=1080,

    # Fingerprint spoofing
    webgl_vendor=&quot;Intel Inc.&quot;,
    webgl_renderer=&quot;Intel Iris OpenGL Engine&quot;,
    user_agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)...&quot;,

    # Behavior configuration
    human_delay_min=0.1,              # Minimum delay between actions (seconds)
    human_delay_max=0.3,              # Maximum delay
    enable_mouse_movement=True,       # Simulate mouse paths
    typing_speed_variance=0.3,        # 30% variance in typing speed
)

with StealthBrowser(config=config) as sb:
    sb.open(&quot;https://protected-site.com&quot;)
</code></pre>
    <hr />
    <h2 id="handling-specific-protections">Handling Specific Protections</h2>
    <h3 id="cloudflare-turnstile">Cloudflare Turnstile</h3>
    <pre><code class="language-python">from stealthautomation import StealthBrowser

with StealthBrowser() as sb:
    sb.open(&quot;https://site-with-cloudflare.com&quot;)

    # Stealth wrapper handles the challenge automatically
    # by appearing as a real browser

    # Wait for any challenge to complete
    sb.wait_for_element(&quot;#main-content&quot;, timeout=30)

    # Continue with normal testing
    sb.assert_text_visible(&quot;Welcome&quot;)
</code></pre>
    <h3 id="recaptcha-v3-invisible">reCAPTCHA v3 (Invisible)</h3>
    <pre><code class="language-python"># reCAPTCHA v3 scores behavior, not puzzles
# Stealth mode increases score by acting human

with StealthBrowser() as sb:
    sb.open(&quot;https://site-with-recaptcha.com&quot;)

    # Spend time on page like a real user
    sb.scroll_down()
    time.sleep(2)
    sb.move_mouse_to_element(&quot;#some-section&quot;)

    # Now interact
    sb.click(&quot;#protected-button&quot;)
</code></pre>
    <hr />
    <h2 id="cicd-integration">CI/CD Integration</h2>
    <h3 id="github-actions">GitHub Actions</h3>
    <pre><code class="language-yaml">name: Stealth Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install stealthautomation pytest

      - name: Install Chrome
        run: |
          wget -q https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
          sudo apt-get install ./google-chrome-stable_current_amd64.deb

      - name: Install Xvfb (virtual display)
        run: sudo apt-get install -y xvfb

      - name: Run tests
        run: |
          # Start virtual display
          Xvfb :99 -screen 0 1920x1080x24 &amp;
          export DISPLAY=:99

          # Run tests
          pytest tests/ -v
</code></pre>
    <hr />
    <h2 id="debugging-detection-issues">Debugging Detection Issues</h2>
    <pre><code class="language-python">from stealthautomation import StealthBrowser, check_detection

with StealthBrowser() as sb:
    # Check what detection services might see
    detection_report = check_detection(sb)

    print(&quot;=== Detection Report ===&quot;)
    print(f&quot;WebDriver flag visible: {detection_report['webdriver_visible']}&quot;)
    print(f&quot;Plugins detected: {detection_report['plugins_count']}&quot;)
    print(f&quot;WebGL available: {detection_report['webgl_available']}&quot;)
    print(f&quot;Canvas fingerprint: {detection_report['canvas_hash'][:20]}...&quot;)

    # Test against known detection sites
    sb.open(&quot;https://bot.sannysoft.com&quot;)
    sb.save_screenshot(&quot;bot_test.png&quot;)

    sb.open(&quot;https://browserleaks.com/javascript&quot;)
    sb.save_screenshot(&quot;browserleaks_test.png&quot;)
</code></pre>
    <hr />
    <h2 id="ethical-considerations">âš ï¸ Ethical Considerations</h2>
    <p><strong>Important:</strong> Stealth automation should only be used for:
        - âœ… Testing your own applications
        - âœ… Testing applications where you have explicit permission
        - âœ… QA environments with security controls similar to production</p>
    <p><strong>Not for:</strong>
        - âŒ Scraping data without permission
        - âŒ Bypassing rate limits on third-party services
        - âŒ Any malicious purposes</p>
    <hr />
    <h1 id="part-v-modern-web-architectures">PART V: MODERN WEB ARCHITECTURES</h1>
    <h2 id="conquering-shadow-dom-and-web-components">Conquering Shadow DOM and Web Components</h2>
    <blockquote>
        <p><em>"The shadow boundary is a wallâ€”but every wall has a door."</em></p>
    </blockquote>
    <hr />
    <h1 id="chapter-9-understanding-shadow-dom">Chapter 9: Understanding Shadow DOM</h1>
    <h2 id="what-is-shadow-dom-and-why-does-it-exist">What Is Shadow DOM and Why Does It Exist?</h2>
    <p>Shadow DOM is a web standard that enables <strong>encapsulation</strong>. It creates a separate DOM tree hidden
        from the main document:</p>
    <pre><code class="language-html">&lt;!-- Main Page (Light DOM) --&gt;
&lt;body&gt;
    &lt;h1&gt;Welcome&lt;/h1&gt;

    &lt;!-- This is a custom element --&gt;
    &lt;custom-button id=&quot;my-button&quot;&gt;
        &lt;!-- Shadow boundary starts here --&gt;
        #shadow-root (open)
            &lt;style&gt;
                /* These styles ONLY affect shadow content */
                button { background: blue; color: white; }
            &lt;/style&gt;
            &lt;button class=&quot;inner-btn&quot;&gt;
                &lt;slot&gt;&lt;/slot&gt;  &lt;!-- Content projection --&gt;
            &lt;/button&gt;
        &lt;!-- Shadow boundary ends here --&gt;

        Click Me  &lt;!-- This text goes into the &lt;slot&gt; --&gt;
    &lt;/custom-button&gt;
&lt;/body&gt;
</code></pre>
    <h3 id="visual-representation">Visual Representation</h3>
    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        DOCUMENT                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    LIGHT DOM                               â”‚  â”‚
â”‚  â”‚                                                            â”‚  â”‚
â”‚  â”‚  &lt;body&gt;                                                    â”‚  â”‚
â”‚  â”‚    &lt;h1&gt;Welcome&lt;/h1&gt;                                        â”‚  â”‚
â”‚  â”‚    &lt;custom-button id=&quot;my-button&quot;&gt;                          â”‚  â”‚
â”‚  â”‚      â•‘                                                     â”‚  â”‚
â”‚  â”‚      â•‘ SHADOW BOUNDARY                                     â”‚  â”‚
â”‚  â”‚      â•‘ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚  â”‚
â”‚  â”‚      â•‘ â”‚ #shadow-root                                 â”‚    â”‚  â”‚
â”‚  â”‚      â•‘ â”‚   &lt;style&gt;...&lt;/style&gt;                         â”‚    â”‚  â”‚
â”‚  â”‚      â•‘ â”‚   &lt;button class=&quot;inner-btn&quot;&gt;                â”‚    â”‚  â”‚
â”‚  â”‚      â•‘ â”‚     &lt;slot&gt;&lt;/slot&gt;                           â”‚    â”‚  â”‚
â”‚  â”‚      â•‘ â”‚   &lt;/button&gt;                                 â”‚    â”‚  â”‚
â”‚  â”‚      â•‘ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚  â”‚
â”‚  â”‚      &quot;Click Me&quot; (slotted content)                          â”‚  â”‚
â”‚  â”‚    &lt;/custom-button&gt;                                        â”‚  â”‚
â”‚  â”‚  &lt;/body&gt;                                                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
    <p style="text-align: center; margin: 2rem 0;">
        <img src="/book/images/shadow_dom.png" alt="Shadow DOM Structure"
            style="max-width: 100%; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);" />
    </p>
    <hr />
    <h2 id="why-frameworks-use-shadow-dom">Why Frameworks Use Shadow DOM</h2>
    <h3 id="1-style-encapsulation">1. Style Encapsulation</h3>
    <pre><code class="language-css">/* Without Shadow DOM: Styles leak everywhere */
.btn { background: red; }   /* Affects ALL .btn on page */

/* With Shadow DOM: Styles are scoped */
/* Inside shadow: */ .btn { background: blue; }
/* These don't affect each other! */
</code></pre>
    <h3 id="2-dom-encapsulation">2. DOM Encapsulation</h3>
    <pre><code class="language-javascript">// Without Shadow DOM:
document.querySelector('.btn');  // Finds ANY .btn

// With Shadow DOM:
document.querySelector('.inner-btn');  // Returns null!
// Button is hidden inside shadow root
</code></pre>
    <h3 id="3-clean-component-apis">3. Clean Component APIs</h3>
    <p>The component's internal structure is an implementation detail. Users of the component only see:</p>
    <pre><code class="language-html">&lt;custom-button&gt;Click Me&lt;/custom-button&gt;
</code></pre>
    <p>Not the internal <code>&lt;button&gt;</code>, <code>&lt;style&gt;</code>, or implementation details.</p>
    <hr />
    <h2 id="frameworks-that-use-shadow-dom">Frameworks That Use Shadow DOM</h2>
    <table>
        <thead>
            <tr>
                <th>Framework</th>
                <th>Shadow DOM Usage</th>
                <th>Difficulty for Testing</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Salesforce Lightning (LWC)</strong></td>
                <td>Extensive, deeply nested</td>
                <td>Very High</td>
            </tr>
            <tr>
                <td><strong>Angular Material</strong></td>
                <td>Optional per component</td>
                <td>Medium</td>
            </tr>
            <tr>
                <td><strong>Ionic Framework</strong></td>
                <td>All components</td>
                <td>High</td>
            </tr>
            <tr>
                <td><strong>Shoelace</strong></td>
                <td>All components</td>
                <td>High</td>
            </tr>
            <tr>
                <td><strong>SAP UI5</strong> (Web Components)</td>
                <td>All components</td>
                <td>High</td>
            </tr>
            <tr>
                <td><strong>Vaadin</strong></td>
                <td>All components</td>
                <td>High</td>
            </tr>
            <tr>
                <td><strong>Adobe Spectrum</strong></td>
                <td>All components</td>
                <td>High</td>
            </tr>
        </tbody>
    </table>
    <hr />
    <h2 id="why-standard-selenium-fails_1">Why Standard Selenium Fails</h2>
    <pre><code class="language-python"># This element is inside a shadow root
driver.find_element(By.CSS_SELECTOR, &quot;button.inner-btn&quot;)
# NoSuchElementException: Unable to locate element

# Even XPath fails
driver.find_element(By.XPATH, &quot;//button[@class='inner-btn']&quot;)
# NoSuchElementException

# The shadow boundary is a HARD WALL
# querySelector() cannot cross it
</code></pre>
    <h3 id="deep-dive-why-standard-queries-fail">ğŸ” Deep Dive: Why Standard Queries Fail</h3>
    <pre><code class="language-javascript">// This is what Selenium executes internally:
document.querySelector(&quot;button.inner-btn&quot;)  // Returns null

// The button exists, but it's in a separate DOM tree
// You must access the shadow root first:
const host = document.querySelector(&quot;custom-button&quot;);
const shadow = host.shadowRoot;
const button = shadow.querySelector(&quot;button.inner-btn&quot;);  // Found!
</code></pre>
    <hr />
    <h1 id="chapter-10-lumos-shadowdom-illuminating-the-darkness">Chapter 10: Lumos ShadowDOM - Illuminating the
        Darkness</h1>
    <h2 id="how-lumos-works">How Lumos Works</h2>
    <p><strong>Lumos ShadowDOM</strong> extends Selenium WebDriver with shadow-aware methods by injecting JavaScript
        that traverses shadow boundaries.</p>
    <h3 id="installation_2">Installation</h3>
    <pre><code class="language-bash">pip install lumos-shadowdom
</code></pre>
    <h3 id="basic-usage_2">Basic Usage</h3>
    <pre><code class="language-python">from selenium import webdriver
from lumos_shadowdom import patch_driver

# Patch the driver with shadow DOM support
driver = patch_driver(webdriver.Chrome())

driver.get(&quot;https://app-with-shadow-dom.com&quot;)

# Find element inside shadow DOM
shadow_button = driver.find_shadow(&quot;custom-button&quot;, &quot;button.inner-btn&quot;)
shadow_button.click()

# Find with multiple shadow boundaries
deep_element = driver.find_deep(
    &quot;outer-component&quot;,    # Host element 1
    &quot;inner-component&quot;,    # Host element 2 (inside first shadow)
    &quot;button.submit&quot;       # Target element (inside second shadow)
)
</code></pre>
    <hr />
    <h2 id="deep-dive-how-shadow-traversal-works">ğŸ” Deep Dive: How Shadow Traversal Works</h2>
    <pre><code class="language-javascript">// Lumos injects this JavaScript into the browser
function findInShadow(hostSelector, targetSelector) {
    // Step 1: Find the host element in light DOM
    const host = document.querySelector(hostSelector);
    if (!host) return null;

    // Step 2: Access its shadow root
    const shadowRoot = host.shadowRoot;
    if (!shadowRoot) {
        // Might be a closed shadow root - more complex handling needed
        return null;
    }

    // Step 3: Query inside the shadow root
    return shadowRoot.querySelector(targetSelector);
}

// For deeply nested shadows, recursive traversal:
function findDeep(...selectors) {
    let current = document;

    for (let i = 0; i &lt; selectors.length - 1; i++) {
        current = current.querySelector(selectors[i]);
        if (!current) return null;
        current = current.shadowRoot;
        if (!current) return null;
    }

    // Last selector is the target element
    return current.querySelector(selectors[selectors.length - 1]);
}
</code></pre>
    <hr />
    <h3 id="deep-dive-closed-shadow-roots">ğŸ” Deep Dive: The Closed Shadow Root Challenge</h3>
    <p>Standard automation tools have zero access to "closed" shadow roots (<code>shadowRoot</code> returns
        <code>null</code>).
        To bypass this, Lumos uses a technique called <strong>Prototype Patching</strong>. Before the website's
        components even load, Lumos injects a script that replaces <code>Element.prototype.attachShadow</code>
        with a custom version that always sets <code>mode: 'open'</code>, regardless of what the developer
        intended. This "unlocks" the entire component tree for automation.
    </p>
    <hr />
    <h2 id="multi-level-shadow-traversal">Multi-Level Shadow Traversal</h2>
    <p>Real-world example with Salesforce Lightning:</p>
    <pre><code class="language-python"># Lightning Web Components are deeply nested
# Structure: page â†’ record-form â†’ input-field â†’ input â†’ actual &lt;input&gt;

# Deep nesting: light DOM â†’ shadow â†’ shadow â†’ shadow â†’ target
lightning_input = driver.find_deep(
    &quot;lightning-record-form&quot;,           # Level 1: The form component
    &quot;lightning-input-field&quot;,           # Level 2: Field wrapper
    &quot;lightning-input&quot;,                 # Level 3: Input component
    &quot;input[type='text']&quot;               # Level 4: Actual input element
)

lightning_input.send_keys(&quot;Hello World&quot;)
</code></pre>
    <h3 id="visualizing-the-traversal">Visualizing the Traversal</h3>
    <pre><code>DOCUMENT
  â””â”€â”€ lightning-record-form
        â””â”€â”€ #shadow-root
              â””â”€â”€ lightning-input-field[data-field=&quot;Name&quot;]
                    â””â”€â”€ #shadow-root
                          â””â”€â”€ lightning-input
                                â””â”€â”€ #shadow-root
                                      â””â”€â”€ input[type=&quot;text&quot;]  â† TARGET
</code></pre>
    <hr />
    <h2 id="smart-text-search">Smart Text Search</h2>
    <p>When you don't know the structure, search by visible text:</p>
    <pre><code class="language-python"># Find element by visible text, even inside shadows
submit_button = driver.find_shadow_text(&quot;Submit Order&quot;)

# Find with partial match
cancel_link = driver.find_shadow_text(&quot;Cancel&quot;, partial=True)

# Find input by its label (accessibility pattern)
email_input = driver.find_shadow_by_label(&quot;Email Address&quot;)
</code></pre>
    <hr />
    <h2 id="selector-discovery-tool">Selector Discovery Tool</h2>
    <p>When you're exploring an unfamiliar app:</p>
    <pre><code class="language-python">from lumos_shadowdom import discover_selectors

# Analyze page and generate selectors for interactive elements
selectors = discover_selectors(
    driver,
    visual_label=&quot;Email Address&quot;,  # What the user sees
    element_type=&quot;input&quot;           # What type of element
)

print(selectors)
# {
#     'selector': 'ui-input-field::shadow input[name=&quot;email&quot;]',
#     'shadow_path': ['ui-form', 'ui-input-field'],
#     'confidence': 0.95,
#     'code': 'driver.find_deep(&quot;ui-form&quot;, &quot;ui-input-field&quot;, &quot;input[name=\\'email\\']&quot;)'
# }
</code></pre>
    <hr />
    <h2 id="handling-mixed-lightshadow-dom">Handling Mixed Light/Shadow DOM</h2>
    <p>Most real apps have both:</p>
    <pre><code class="language-python"># Regular elements in light DOM
page_title = driver.find_element(By.TAG_NAME, &quot;h1&quot;)  # Standard Selenium

# Form is in light DOM, but fields are shadow components
form = driver.find_element(By.ID, &quot;contact-form&quot;)

# Fields inside shadow components
email_field = driver.find_shadow(&quot;custom-input[name='email']&quot;, &quot;input&quot;)
phone_field = driver.find_shadow(&quot;custom-input[name='phone']&quot;, &quot;input&quot;)

# Submit button might be in light DOM
submit = form.find_element(By.CSS_SELECTOR, &quot;button[type='submit']&quot;)

# Or in shadow DOM
submit = driver.find_shadow(&quot;custom-button[type='submit']&quot;, &quot;button&quot;)
</code></pre>
    <hr />
    <h1 id="part-vi-ai-intelligent-automation">PART VI: AI &amp; INTELLIGENT AUTOMATION</h1>
    <h2 id="leveraging-ai-for-smarter-testing">Leveraging AI for Smarter Testing</h2>
    <hr />
    <h1 id="chapter-11-selector-scout-ai-generated-resilient-locators">Chapter 11: Selector Scout - AI-Generated
        Resilient Locators</h1>
    <h2 id="the-selector-maintenance-problem">The Selector Maintenance Problem</h2>
    <p>Selectors break constantly:
        - Developers change IDs during refactoring
        - Class names are generated by CSS-in-JS libraries
        - DOM structure changes without notice
        - Dynamic IDs change on every page load</p>
    <p><strong>Studies show: 30% of automation engineer time goes to selector maintenance.</strong></p>
    <h3 id="the-brittle-selector-spectrum">ğŸ” Deep Dive: The Brittle Selector Spectrum</h3>
    <pre><code class="language-python"># âŒ MOST BRITTLE: Auto-generated IDs
driver.find_element(By.ID, &quot;input_email_7x9k2&quot;)  # Changes each build

# âš ï¸ SOMEWHAT BRITTLE: Generated class names
driver.find_element(By.CSS_SELECTOR, &quot;.MuiInput-root-1234&quot;)  # Material-UI

# âœ“ BETTER: data-testid (but requires dev cooperation)
driver.find_element(By.CSS_SELECTOR, &quot;[data-testid='email-input']&quot;)

# âœ“ MORE RESILIENT: Semantic attributes
driver.find_element(By.CSS_SELECTOR, &quot;input[type='email'][name='email']&quot;)

# âœ“ MOST RESILIENT: Semantic path with context
driver.find_element(By.XPATH, &quot;//form[@aria-label='Login']//input[@type='email']&quot;)
</code></pre>
    <hr />
    <h2 id="selector-scouts-ai-approach">Selector Scout's AI Approach</h2>
    <p>Selector Scout uses AI (Google Gemini) to analyze HTML and generate resilient selectors:</p>
    <pre><code class="language-python">from selector_scout import SelectorScout

scout = SelectorScout(api_key=&quot;your-gemini-api-key&quot;)

# Paste raw HTML from DevTools
selectors = scout.analyze(&quot;&quot;&quot;
&lt;div class=&quot;form_7x92ka login-module&quot;&gt;
    &lt;div class=&quot;field_container_abc123&quot;&gt;
        &lt;label for=&quot;email-1234&quot;&gt;Email Address&lt;/label&gt;
        &lt;input 
            id=&quot;email-1234&quot; 
            type=&quot;email&quot; 
            data-testid=&quot;login-email&quot;
            class=&quot;input_xyz789 form-control&quot;
            placeholder=&quot;Enter your email&quot;
        &gt;
    &lt;/div&gt;
&lt;/div&gt;
&quot;&quot;&quot;)

print(selectors)
# {
#     &quot;primary&quot;: &quot;[data-testid='login-email']&quot;,
#     &quot;fallbacks&quot;: [
#         &quot;input[type='email'][placeholder='Enter your email']&quot;,
#         &quot;input[type='email']&quot;,
#         &quot;#email-1234&quot;
#     ],
#     &quot;xpath&quot;: &quot;//label[contains(text(),'Email')]/following-sibling::input&quot;,
#     &quot;strategy_notes&quot;: &quot;Primary uses data-testid (stable). Fallback 1 uses 
#                        semantic attributes. Avoid ID as it appears auto-generated.&quot;
# }
</code></pre>
    <hr />
    <h2 id="batch-analysis-and-page-object-generation">Batch Analysis and Page Object Generation</h2>
    <pre><code class="language-python">from selector_scout import SelectorScout

scout = SelectorScout(api_key=&quot;your-api-key&quot;)

# Analyze entire page
page_selectors = scout.analyze_page(driver)

print(f&quot;Found {len(page_selectors)} interactive elements&quot;)
for element in page_selectors:
    print(f&quot;{element['label']}: {element['primary_selector']}&quot;)

# Auto-generate Page Object
scout.export_page_object(
    page_selectors,
    output_file=&quot;./pages/login_page.py&quot;,
    class_name=&quot;LoginPage&quot;
)
</code></pre>
    <p><strong>Generated output:</strong></p>
    <pre><code class="language-python"># login_page.py (auto-generated by Selector Scout)
from selenium.webdriver.common.by import By

class LoginPage:
    # Selectors
    EMAIL_INPUT = (By.CSS_SELECTOR, &quot;[data-testid='login-email']&quot;)
    PASSWORD_INPUT = (By.CSS_SELECTOR, &quot;[data-testid='login-password']&quot;)
    SUBMIT_BUTTON = (By.CSS_SELECTOR, &quot;button[type='submit']&quot;)
    FORGOT_PASSWORD_LINK = (By.XPATH, &quot;//a[contains(text(),'Forgot')]&quot;)

    def __init__(self, driver):
        self.driver = driver

    def enter_email(self, email: str):
        self.driver.find_element(*self.EMAIL_INPUT).send_keys(email)

    def enter_password(self, password: str):
        self.driver.find_element(*self.PASSWORD_INPUT).send_keys(password)

    def click_submit(self):
        self.driver.find_element(*self.SUBMIT_BUTTON).click()

    def click_forgot_password(self):
        self.driver.find_element(*self.FORGOT_PASSWORD_LINK).click()
</code></pre>
    <hr />
    <h1 id="chapter-12-testing-genai-chatbots-with-selenium">Chapter 12: Testing GenAI Chatbots with Selenium</h1>
    <h2 id="the-unique-challenges-of-ai-interfaces">The Unique Challenges of AI Interfaces</h2>
    <p>Testing GenAI chatbots breaks traditional automation patterns:</p>
    <h3 id="challenge-1-streaming-responses">Challenge 1: Streaming Responses</h3>
    <p>Chatbots type responses token-by-token. There's no single moment where the response is "complete."</p>
    <pre><code>Timeline of a chatbot response:
  0ms:   &quot;&quot;
 100ms:  &quot;The&quot;
 200ms:  &quot;The capital&quot;
 300ms:  &quot;The capital of&quot;
 400ms:  &quot;The capital of France&quot;
 500ms:  &quot;The capital of France is&quot;
 600ms:  &quot;The capital of France is Paris&quot;
 700ms:  &quot;The capital of France is Paris.&quot;

When do you assert? Any assertion before 700ms will catch incomplete text!
</code></pre>
    <h3 id="challenge-2-non-deterministic-output">Challenge 2: Non-Deterministic Output</h3>
    <p>Same prompt yields different responses:</p>
    <pre><code>Prompt: &quot;What's 2+2?&quot;

Response 1: &quot;2+2 equals 4.&quot;
Response 2: &quot;The answer is 4.&quot;
Response 3: &quot;Four.&quot;
Response 4: &quot;2 plus 2 is 4!&quot;
Response 5: &quot;The sum of 2 and 2 is 4.&quot;

Traditional assertEquals fails even though all are correct!
</code></pre>
    <h3 id="challenge-3-variable-latency">Challenge 3: Variable Latency</h3>
    <ul>
        <li>First token might take 500ms or 5000ms</li>
        <li>Total response time varies by length</li>
        <li>Server load affects response speed</li>
    </ul>
    <hr />
    <h2 id="selenium-chatbot-test-library">Selenium Chatbot Test Library</h2>
    <pre><code class="language-bash">pip install selenium-chatbot-test
</code></pre>
    <h3 id="core-component-1-streamwaiter">Core Component 1: StreamWaiter</h3>
    <p>Detects when streaming has truly completed:</p>
    <pre><code class="language-python">from selenium_chatbot_test import StreamWaiter

waiter = StreamWaiter(
    driver,
    response_selector=&quot;#chat-response&quot;,
    stability_threshold=500,  # ms of no changes = complete
    timeout=30000             # max wait time
)

# Send message
driver.find_element(By.ID, &quot;chat-input&quot;).send_keys(&quot;What is Python?&quot;)
driver.find_element(By.ID, &quot;send-button&quot;).click()

# Wait for streaming to complete
response_text = waiter.wait_for_completion()
print(f&quot;Bot responded: {response_text}&quot;)
</code></pre>
    <h3 id="core-component-2-semanticassert">Core Component 2: SemanticAssert</h3>
    <p>Assert meaning, not exact text:</p>
    <pre><code class="language-python">from selenium_chatbot_test import SemanticAssert

asserter = SemanticAssert(model=&quot;all-MiniLM-L6-v2&quot;)

# These all mean the same thing
response = &quot;The capital city of France is Paris.&quot;

assert asserter.similar(
    response, 
    &quot;Paris is France's capital&quot;,
    threshold=0.75  # 75% semantic similarity required
)

# Check for concept presence
assert asserter.contains_concept(response, &quot;Paris&quot;)
assert asserter.contains_concept(response, &quot;capital&quot;)
</code></pre>
    <h3 id="core-component-3-latencymonitor">Core Component 3: LatencyMonitor</h3>
    <p>Track performance metrics:</p>
    <pre><code class="language-python">from selenium_chatbot_test import LatencyMonitor

monitor = LatencyMonitor(driver, response_selector=&quot;#chat-response&quot;)

driver.find_element(By.ID, &quot;chat-input&quot;).send_keys(&quot;Hello!&quot;)
driver.find_element(By.ID, &quot;send-button&quot;).click()

metrics = monitor.measure()

print(f&quot;Time to First Token (TTFT): {metrics.ttft_ms}ms&quot;)
print(f&quot;Tokens per second: {metrics.tokens_per_second}&quot;)
print(f&quot;Total response time: {metrics.total_time_ms}ms&quot;)

# Performance assertions
assert metrics.ttft_ms &lt; 2000, &quot;First token too slow&quot;
assert metrics.tokens_per_second &gt; 20, &quot;Streaming too slow&quot;
</code></pre>
    <hr />
    <h1 id="chapter-13-pytest-mockllm-testing-ai-features-without-api-costs">Chapter 13: Pytest-MockLLM - Testing AI
        Features Without API Costs</h1>
    <h2 id="the-problem-with-testing-llm-powered-features">The Problem with Testing LLM-Powered Features</h2>
    <p>Every call to OpenAI/Claude/Gemini costs money and time:
        - API calls: $0.01-$0.10 per request
        - Latency: 500ms-5000ms per call
        - Rate limits: 60-1000 requests/minute
        - Non-determinism: Same prompt, different results</p>
    <p>For a CI pipeline running 50+ tests 10 times daily:
        - <strong>500+ API calls/day</strong>
        - <strong>$50-500/month just for testing</strong>
        - <strong>Flaky tests from non-determinism</strong></p>
    <h2 id="pytest-mockllm-solution">Pytest-MockLLM Solution</h2>
    <pre><code class="language-bash">pip install pytest-mockllm
</code></pre>
    <h3 id="basic-usage_3">Basic Usage</h3>
    <pre><code class="language-python">import pytest
from pytest_mockllm import mock_openai

@pytest.fixture
def mock_llm():
    with mock_openai() as mock:
        # Configure response
        mock.set_response(&quot;Hello! How can I help you today?&quot;)
        yield mock

def test_chatbot_greeting(mock_llm, chatbot):
    response = chatbot.send_message(&quot;Hi!&quot;)

    # Response is deterministic and instant
    assert &quot;help you&quot; in response.lower()

    # Verify the mock was called
    assert mock_llm.call_count == 1
    assert &quot;Hi!&quot; in mock_llm.last_prompt
</code></pre>
    <h3 id="deep-dive-request-normalization">ğŸ” Deep Dive: Request Normalization and Matching</h3>
    <p>To identify which mock response to return, Pytest-MockLLM uses <strong>Request Normalization</strong>. It
        doesn't just look for an exact string match (which fails on minor whitespace or formatting changes).
        Instead, it strips out non-semantic characters, hashes the resulting prompt, and uses a <strong>Levenshtein
            Distance</strong> algorithm for "fuzzy" matching. This ensures your tests remain stable even if the
        underlying prompt template undergoes minor cosmetic refactoring.</p>
    <hr />
    <h3 id="recording-and-playback">Recording and Playback</h3>
    <pre><code class="language-python">from pytest_mockllm import record_responses, playback_responses

# Step 1: Record real responses (run once)
@record_responses(&quot;./cassettes/chat_flow.json&quot;)
def test_chat_flow_record():
    response = openai.ChatCompletion.create(
        model=&quot;gpt-4&quot;,
        messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Hello&quot;}]
    )
    assert response is not None

# Step 2: Playback in CI (no API calls)
@playback_responses(&quot;./cassettes/chat_flow.json&quot;)
def test_chat_flow():
    response = openai.ChatCompletion.create(
        model=&quot;gpt-4&quot;,
        messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Hello&quot;}]
    )
    # Uses recorded response, instant, free
    assert &quot;Hello&quot; in response.choices[0].message.content
</code></pre>
    <h3 id="chaos-engineering-for-edge-cases">Chaos Engineering for Edge Cases</h3>
    <pre><code class="language-python">from pytest_mockllm import mock_openai, Chaos

def test_handles_timeout():
    with mock_openai() as mock:
        mock.set_chaos(Chaos.TIMEOUT, probability=1.0)

        with pytest.raises(TimeoutError):
            openai.ChatCompletion.create(...)

def test_handles_rate_limit():
    with mock_openai() as mock:
        mock.set_chaos(Chaos.RATE_LIMIT, probability=1.0)

        # Should trigger retry logic
        response = my_app.call_with_retry(...)
        assert response is not None
</code></pre>
    <h3 id="pii-redaction">PII Redaction</h3>
    <pre><code class="language-python">from pytest_mockllm import PIIRedactor

# Automatically redact sensitive data from recorded cassettes
redactor = PIIRedactor()
redactor.add_pattern(r&quot;API_KEY_\w+&quot;, &quot;[REDACTED_API_KEY]&quot;)
redactor.add_pattern(r&quot;\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b&quot;, &quot;[EMAIL]&quot;)

@record_responses(&quot;./cassettes/test.json&quot;, redactor=redactor)
def test_with_pii():
    # Personal data automatically scrubbed from recordings
    pass
</code></pre>
    <hr />
    <h2 id="parts-iv-vi-summary">ğŸ“‹ Parts IV-VI Summary</h2>
    <table>
        <thead>
            <tr>
                <th>Topic</th>
                <th>Key Tool</th>
                <th>Problem Solved</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Bot Detection</td>
                <td>StealthAutomation</td>
                <td>Tests blocked by Cloudflare, etc.</td>
            </tr>
            <tr>
                <td>Shadow DOM</td>
                <td>Lumos</td>
                <td>Elements hidden in shadow roots</td>
            </tr>
            <tr>
                <td>AI Selectors</td>
                <td>Selector Scout</td>
                <td>Brittle, breaking selectors</td>
            </tr>
            <tr>
                <td>Chatbot Testing</td>
                <td>selenium-chatbot-test</td>
                <td>Streaming, non-deterministic AI</td>
            </tr>
            <tr>
                <td>LLM Testing</td>
                <td>pytest-mockllm</td>
                <td>API costs, flaky AI tests</td>
            </tr>
        </tbody>
    </table>
    <hr />
    <h1 id="part-vii-visual-automation">PART VII: VISUAL AUTOMATION</h1>
    <h2 id="when-theres-no-dom-at-all">When There's No DOM At All</h2>
    <blockquote>
        <p><em>"In a remote desktop, all you have are pixelsâ€”and your wits."</em></p>
    </blockquote>
    <hr />
    <p style="text-align: center; margin: 2rem 0;">
        <img src="/book/images/visual.png" alt="Visual Testing Workflow"
            style="max-width: 100%; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);" />
    </p>
    <h1 id="chapter-14-visual-sonar-automating-remote-desktops">Chapter 14: Visual Sonar - Automating Remote Desktops
    </h1>
    <h2 id="the-pixelated-frontier">The Pixelated Frontier</h2>
    <p>Remote desktop environments present automation's hardest challenge:</p>
    <table>
        <thead>
            <tr>
                <th>Environment</th>
                <th>DOM Access</th>
                <th>Accessibility API</th>
                <th>What You Get</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Web Browser</td>
                <td>âœ… Full</td>
                <td>âœ… Full</td>
                <td>Elements, attributes, structure</td>
            </tr>
            <tr>
                <td>Native Desktop</td>
                <td>âŒ None</td>
                <td>âœ… Partial</td>
                <td>Some UI elements via UI Automation</td>
            </tr>
            <tr>
                <td>Remote Desktop (Citrix/VDI)</td>
                <td>âŒ None</td>
                <td>âŒ None</td>
                <td><strong>Only pixels</strong></td>
            </tr>
        </tbody>
    </table>
    <p>When you connect to a Citrix session, all you receive is a video stream. There's no DOM, no accessibility tree,
        no UI Automationâ€”just an image.</p>
    <h3 id="traditional-approaches-and-their-problems">Traditional Approaches and Their Problems</h3>
    <p><strong>Approach 1: Coordinate-Based Clicking</strong></p>
    <pre><code class="language-python"># Fragile: Breaks if resolution or window position changes
import pyautogui
pyautogui.click(x=500, y=300)

# One resolution change = all tests broken
</code></pre>
    <p><strong>Approach 2: Image Template Matching</strong></p>
    <pre><code class="language-python"># Better but slow and resolution-dependent
button_location = pyautogui.locateOnScreen('login_button.png')
pyautogui.click(button_location)

# Problems:
# - Different DPI = template doesn't match
# - Different theme = template doesn't match
# - Very slow (scanning entire screen)
</code></pre>
    <hr />
    <h2 id="visual-sonars-innovative-approach">Visual Sonar's Innovative Approach</h2>
    <p>Visual Sonar uses <strong>focus ring detection</strong>: tracking how the visual focus indicator moves through
        the interface using keyboard navigation.</p>
    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   VISUAL SONAR WORKFLOW                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  1. SCREEN CAPTURE                                              â”‚
â”‚     Take screenshot of current state                            â”‚
â”‚                                                                  â”‚
â”‚  2. PRESS TAB KEY                                               â”‚
â”‚     Focus moves to next interactive element                     â”‚
â”‚                                                                  â”‚
â”‚  3. SCREEN CAPTURE                                              â”‚
â”‚     Take screenshot of new state                                â”‚
â”‚                                                                  â”‚
â”‚  4. COMPUTE DIFFERENCE                                          â”‚
â”‚     Find pixels that changed between screenshots                â”‚
â”‚                                                                  â”‚
â”‚  5. DETECT FOCUS RING                                           â”‚
â”‚     Changed region = newly focused element                       â”‚
â”‚                                                                  â”‚
â”‚  6. OCR EXTRACTION                                              â”‚
â”‚     Read label text near the focus ring                        â”‚
â”‚                                                                  â”‚
â”‚  7. INTERACTION                                                 â”‚
â”‚     If label matches target, type or click                     â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
    <hr />
    <h2 id="installation_3">Installation</h2>
    <pre><code class="language-bash">pip install visual-sonar pytesseract

# Also install Tesseract OCR binary:
# Windows: Download from https://github.com/UB-Mannheim/tesseract/wiki
# Mac: brew install tesseract
# Linux: sudo apt-get install tesseract-ocr
</code></pre>
    <h2 id="basic-usage_4">Basic Usage</h2>
    <pre><code class="language-python">from visual_sonar import VisualSonar

sonar = VisualSonar()

# Navigate to a field by tabbing until we find it
sonar.tab_to_field(&quot;Username&quot;)

# Type in the focused field
sonar.type_text(&quot;admin@company.com&quot;)

# Tab to next field
sonar.tab_to_field(&quot;Password&quot;)
sonar.type_text(&quot;secretpassword&quot;)

# Find and click a button by visible text
sonar.click_text(&quot;Sign In&quot;)

# Or by template image
sonar.click_image(&quot;templates/login_button.png&quot;)
</code></pre>
    <hr />
    <h2 id="focus-ring-detection-deep-dive">ğŸ” Deep Dive: How Focus Ring Detection Works</h2>
    <pre><code class="language-python">from visual_sonar import VisualSonar, FocusDetector

detector = FocusDetector(
    focus_ring_colors=[&quot;#0078d4&quot;, &quot;#005a9e&quot;],  # Common blue focus colors
    min_focus_area=100,                         # Minimum pixel area for focus ring
    max_focus_area=50000,                       # Maximum pixel area
    difference_threshold=30,                    # Pixel intensity difference threshold
)

sonar = VisualSonar(focus_detector=detector)

# The algorithm:
# 1. Capture baseline screenshot
# 2. Press TAB key
# 3. Capture new screenshot
# 4. Compute absolute difference between images
# 5. Find contiguous region of changed pixels
# 6. Verify size matches expected focus ring
# 7. Calculate centroid = element center
</code></pre>
    <h3 id="per-monitor-dpi-handling">Per-Monitor DPI Handling</h3>
    <pre><code class="language-python">from visual_sonar import VisualSonar, DPIConfig

# Handle mixed DPI scenarios (common in remote desktop)
dpi_config = DPIConfig(
    auto_detect=True,           # Auto-detect per-monitor DPI
    reference_dpi=96,           # Base DPI for template images
    scaling_interpolation=&quot;LANCZOS&quot;  # High-quality scaling
)

sonar = VisualSonar(dpi_config=dpi_config)
</code></pre>
    <hr />
    <h1 id="chapter-15-project-vandal-ui-mutation-testing">Chapter 15: Project Vandal - UI Mutation Testing</h1>
    <h2 id="what-is-mutation-testing">What Is Mutation Testing?</h2>
    <p>Traditional mutation testing modifies source code to verify tests catch bugs. <strong>UI Mutation
            Testing</strong> modifies the UI itself:</p>
    <pre><code>TRADITIONAL MUTATION TESTING:
  1. Take source code
  2. Introduce bug (mutate)
  3. Run tests
  4. If tests pass â†’ weak test coverage (bug not detected)
  5. If tests fail â†’ good coverage (bug detected)

UI MUTATION TESTING:
  1. Load application
  2. Mutate UI (disable button, hide element, change text)
  3. Run automation tests
  4. If tests pass â†’ &quot;zombie tests&quot; that don't check properly
  5. If tests fail â†’ resilient tests that validate correctly
</code></pre>
    <hr />
    <h2 id="the-zombie-test-problem">The "Zombie Test" Problem</h2>
    <p>Many automation tests pass without actually validating anything:</p>
    <pre><code class="language-python"># This test might be a zombie
def test_submit_form():
    driver.find_element(By.ID, &quot;name&quot;).send_keys(&quot;John&quot;)
    driver.find_element(By.ID, &quot;submit&quot;).click()
    # No assertion! Test passes even if form is broken
</code></pre>
    <p>Project Vandal helps identify these weak tests.</p>
    <hr />
    <h2 id="installation_4">Installation</h2>
    <pre><code class="language-bash">pip install vandal-testing
</code></pre>
    <h2 id="basic-usage_5">Basic Usage</h2>
    <pre><code class="language-python">from vandal import Vandal, MutationType

vandal = Vandal(driver)

# Apply mutation: disable the submit button
with vandal.mutate(
    selector=&quot;#submit-button&quot;,
    mutation=MutationType.STEALTH_DISABLE
):
    # Run your test in this context
    # If test still passes, it's weak!
    run_submit_test()

# Mutation automatically reverted after context exits
</code></pre>
    <hr />
    <h2 id="mutation-strategies">ğŸ” Deep Dive: Mutation Strategies</h2>
    <h3 id="1-stealth-disable">1. Stealth Disable</h3>
    <p>Makes element non-functional but visually identical:</p>
    <pre><code class="language-python">MutationType.STEALTH_DISABLE
# JavaScript: element.disabled = true; (for buttons)
# Or: element.style.pointerEvents = 'none';
</code></pre>
    <h3 id="2-ghost-element">2. Ghost Element</h3>
    <p>Hides element from interaction but keeps it in DOM:</p>
    <pre><code class="language-python">MutationType.GHOST_ELEMENT
# JavaScript: element.style.visibility = 'hidden';
# element.style.height = '0'; element.style.overflow = 'hidden';
</code></pre>
    <h3 id="3-data-sabotage">3. Data Sabotage</h3>
    <p>Changes text content to verify tests actually read values:</p>
    <pre><code class="language-python">MutationType.DATA_SABOTAGE
# JavaScript: element.textContent = 'VANDALIZED';
# element.value = 'WRONG_VALUE';
</code></pre>
    <h3 id="4-logic-sabotage">4. Logic Sabotage</h3>
    <p>Breaks JavaScript event handlers:</p>
    <pre><code class="language-python">MutationType.LOGIC_SABOTAGE  
# JavaScript: Removes all event listeners from element
</code></pre>
    <hr />
    <h2 id="mutation-score">Mutation Score</h2>
    <pre><code class="language-python">from vandal import VandalRunner

runner = VandalRunner(driver)

# Run mutation testing across your test suite
report = runner.run_mutations(
    test_function=run_checkout_tests,
    selectors=[&quot;#add-to-cart&quot;, &quot;#checkout&quot;, &quot;#pay-now&quot;],
    mutations=[MutationType.STEALTH_DISABLE, MutationType.GHOST_ELEMENT]
)

print(f&quot;Mutation Score: {report.score}%&quot;)
# 100% = all mutations detected (tests failed as expected)
# &lt;100% = some mutations not detected (zombie tests exist)

for result in report.results:
    if result.mutation_survived:
        print(f&quot;âš ï¸ ZOMBIE: {result.test_name} didn't detect {result.mutation}&quot;)
</code></pre>
    <hr />
    <h1 id="part-viii-reporting-observability">PART VIII: REPORTING &amp; OBSERVABILITY</h1>
    <h2 id="making-quality-visible">Making Quality Visible</h2>
    <hr />
    <h1 id="chapter-16-pytest-glow-report-enterprise-grade-reporting">Chapter 16: pytest-glow-report - Enterprise-Grade
        Reporting</h1>
    <h2 id="beyond-developer-output">Beyond Developer Output</h2>
    <p>Standard pytest output serves developers:</p>
    <pre><code>test_login.py::test_valid_login PASSED
test_login.py::test_invalid_password FAILED
test_checkout.py::test_add_to_cart PASSED
</code></pre>
    <p>But stakeholders need:
        - <strong>Executive Summary</strong>: Can we release?
        - <strong>Quality Metrics</strong>: How stable is the system?
        - <strong>Trend Analysis</strong>: Are we improving over time?
        - <strong>Visual Evidence</strong>: What was actually tested?</p>
    <hr />
    <h2 id="installation_5">Installation</h2>
    <pre><code class="language-bash">pip install pytest-glow-report
</code></pre>
    <h2 id="configuration">Configuration</h2>
    <pre><code class="language-ini"># pytest.ini
[pytest]
addopts = --glow-report=./reports/ --glow-report-title=&quot;E-Commerce Test Suite&quot;
</code></pre>
    <h2 id="report-features">Report Features</h2>
    <h3 id="1-executive-dashboard">1. Executive Dashboard</h3>
    <p>The report header shows:
        - Overall pass rate with RAG (Red/Amber/Green) status
        - Quality Score (0-100)
        - Release Recommendation (Go/No-Go/Conditional)
        - Test execution time
        - Environment information</p>
    <h3 id="deep-dive-quality-score">ğŸ” Deep Dive: The Quality Score Algorithm</h3>
    <pre><code class="language-python"># Quality Score formula:
quality_score = (
    pass_rate * 0.5 +           # 50% weight: raw pass rate
    stability * 0.25 +          # 25% weight: test stability over time
    coverage * 0.15 +           # 15% weight: code coverage
    speed * 0.10                # 10% weight: execution time vs baseline
)

# Ratings:
# 90-100: Excellent (Release Ready) âœ…
# 75-89:  Good (Minor Issues) âš ï¸
# 60-74:  Fair (Needs Attention) âš ï¸
# &lt;60:    Poor (Block Release) âŒ
</code></pre>
    <h3 id="3-screenshot-integration">3. Screenshot Integration</h3>
    <pre><code class="language-python">import pytest

def test_checkout(driver, glow_report):
    driver.get(&quot;https://shop.example.com/checkout&quot;)

    # Capture step screenshot
    glow_report.screenshot(driver, &quot;checkout_page_loaded&quot;)

    driver.find_element(By.ID, &quot;pay-now&quot;).click()

    # Capture result
    glow_report.screenshot(driver, &quot;payment_result&quot;)

    assert &quot;Order Confirmed&quot; in driver.page_source
</code></pre>
    <h3 id="4-failure-clustering">4. Failure Clustering</h3>
    <p>Similar failures are automatically grouped:
        - <code>ElementNotInteractableException</code> in login flow (5 occurrences)
        - Timeout waiting for <code>#dashboard</code> (3 occurrences)
        - Database connection refused (2 occurrences)</p>
    <hr />
    <h1 id="part-ix-enterprise-patterns">PART IX: ENTERPRISE PATTERNS</h1>
    <h2 id="architectures-that-scale">Architectures That Scale</h2>
    <hr />
    <h1 id="chapter-17-the-four-layer-architecture">Chapter 17: The Four-Layer Architecture</h1>
    <h2 id="why-framework-architecture-matters">Why Framework Architecture Matters</h2>
    <p>A well-architected framework:
        - Reduces maintenance by 60%
        - Enables parallel test development
        - Simplifies onboarding new team members
        - Isolates changes to specific layers</p>
    <hr />
    <h2 id="the-four-layers">ğŸ” Deep Dive: The Four-Layer Architecture</h2>
    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       TEST LAYER                                 â”‚
â”‚  â€¢ Test scenarios and cases                                     â”‚
â”‚  â€¢ Business-readable specifications                             â”‚
â”‚  â€¢ NO technical implementation details                          â”‚
â”‚                                                                  â”‚
â”‚  test_checkout.py:                                              â”‚
â”‚    def test_guest_can_complete_purchase():                      â”‚
â”‚        cart.add_product(&quot;SKU-123&quot;)                              â”‚
â”‚        checkout.complete_as_guest()                             â”‚
â”‚        assert order_confirmation.is_displayed()                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     BUSINESS LAYER                               â”‚
â”‚  â€¢ Page Objects / Screen Objects                                â”‚
â”‚  â€¢ Workflow/Journey abstractions                                â”‚
â”‚  â€¢ Domain-specific language                                     â”‚
â”‚                                                                  â”‚
â”‚  cart_page.py:                                                  â”‚
â”‚    class CartPage:                                              â”‚
â”‚        def add_product(self, sku):                              â”‚
â”‚            self.search_box.enter(sku)                           â”‚
â”‚            self.add_button.click()                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       CORE LAYER                                 â”‚
â”‚  â€¢ Base element classes                                         â”‚
â”‚  â€¢ Common actions (click, type, select)                         â”‚
â”‚  â€¢ Assertion helpers                                            â”‚
â”‚  â€¢ Data utilities                                               â”‚
â”‚                                                                  â”‚
â”‚  base_element.py:                                               â”‚
â”‚    class BaseElement:                                           â”‚
â”‚        def click(self):                                         â”‚
â”‚            self.wait_for_clickable()                            â”‚
â”‚            self._element.click()                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  INFRASTRUCTURE LAYER                            â”‚
â”‚  â€¢ WebDriver management                                         â”‚
â”‚  â€¢ Configuration loading                                        â”‚
â”‚  â€¢ Reporting integration                                        â”‚
â”‚  â€¢ CI/CD hooks                                                  â”‚
â”‚                                                                  â”‚
â”‚  driver_factory.py:                                             â”‚
â”‚    class DriverFactory:                                         â”‚
â”‚        def create(self, browser, headless):                     â”‚
â”‚            ...                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
    <hr />
    <h2 id="layer-principles">Layer Principles</h2>
    <table>
        <thead>
            <tr>
                <th>Layer</th>
                <th>Knows About</th>
                <th>Does NOT Know About</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Test</td>
                <td>Business</td>
                <td>Core, Infrastructure</td>
            </tr>
            <tr>
                <td>Business</td>
                <td>Core</td>
                <td>Infrastructure</td>
            </tr>
            <tr>
                <td>Core</td>
                <td>Infrastructure</td>
                <td>Tests, Business logic</td>
            </tr>
            <tr>
                <td>Infrastructure</td>
                <td>Nothing above</td>
                <td>â€”</td>
            </tr>
        </tbody>
    </table>
    <hr />
    <h2 id="api-first-test-data-strategy">API-First Test Data Strategy</h2>
    <pre><code class="language-python"># âŒ DON'T: Create test data through UI (slow, fragile)
def test_order_history(driver):
    login(driver)
    add_product(driver)       # Takes 30 seconds
    checkout(driver)          # Takes another 30 seconds
    navigate_to_history(driver)
    assert_order_visible(driver)

# âœ… DO: Seed data via API, test only the UI part you care about
def test_order_history(driver, api_client):
    # Fast API-based setup (&lt; 1 second)
    user = api_client.create_user()
    order = api_client.create_order(user.id, products=[&quot;SKU-1&quot;])

    # Restore session
    login_via_teleport(driver, user)

    # Only test the UI part we're verifying
    navigate_to_history(driver)
    assert_order_visible(driver, order.id)
</code></pre>
    <hr />
    <h1 id="chapter-18-cicd-integration-patterns">Chapter 18: CI/CD Integration Patterns</h1>
    <h2 id="github-actions-best-practices">GitHub Actions Best Practices</h2>
    <h3 id="matrix-testing">Matrix Testing</h3>
    <pre><code class="language-yaml">name: Cross-Browser Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        browser: [chrome, firefox, edge]
        python-version: ['3.10', '3.11', '3.12']

    steps:
      - uses: actions/checkout@v4

      - name: Setup Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Run tests on ${{ matrix.browser }}
        run: pytest tests/ --browser=${{ matrix.browser }}
</code></pre>
    <h3 id="artifact-management">Artifact Management</h3>
    <pre><code class="language-yaml">      - name: Upload test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-reports-${{ matrix.browser }}
          path: |
            reports/
            screenshots/
          retention-days: 30
</code></pre>
    <h3 id="caching-dependencies">Caching Dependencies</h3>
    <pre><code class="language-yaml">      - name: Cache pip packages
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
</code></pre>
    <hr />
    <h1 id="part-x-specialized-environments">PART X: SPECIALIZED ENVIRONMENTS</h1>
    <hr />
    <h1 id="chapter-19-wvdautomation-windows-virtual-desktop">Chapter 19: WVDAutomation - Windows Virtual Desktop</h1>
    <h2 id="the-wvd-challenge">The WVD Challenge</h2>
    <p>Windows Virtual Desktop (Azure Virtual Desktop) sessions present:
        - Different connection methods than Citrix
        - Azure AD authentication
        - Session persistence challenges
        - Scaling across multiple hosts</p>
    <hr />
    <h2 id="installation_6">Installation</h2>
    <pre><code class="language-bash">pip install wvdautomation
</code></pre>
    <h2 id="basic-usage_6">Basic Usage</h2>
    <pre><code class="language-python">from wvdautomation import WVDSession

session = WVDSession(
    workspace_url=&quot;https://rdweb.wvd.microsoft.com/...&quot;,
    username=&quot;user@company.com&quot;,
    password=os.environ[&quot;WVD_PASSWORD&quot;]
)

with session.connect() as desktop:
    # Now you have a Pyautogui-like interface
    desktop.click_text(&quot;Microsoft Edge&quot;)
    desktop.wait_for_window(&quot;Edge&quot;)
    desktop.type_text(&quot;https://internal-app.company.com&quot;)
</code></pre>
    <hr />
    <h1 id="part-xi-advanced-topics">PART XI: ADVANCED TOPICS</h1>
    <hr />
    <h1 id="chapter-20-effort-estimation-for-automation-projects">Chapter 20: Effort Estimation for Automation Projects
    </h1>
    <h2 id="the-estimation-problem">The Estimation Problem</h2>
    <p>Automation estimation is notoriously inaccurate:
        - "This should take 2 hours" â†’ 2 days
        - "Simple login automation" â†’ 3 weeks (with SSO, MFA, session handling)
        - "Just automate the happy path" â†’ But what about error states?</p>
    <hr />
    <h2 id="the-five-step-framework">The Five-Step Framework</h2>
    <h3 id="step-1-decompose-ruthlessly">Step 1: Decompose Ruthlessly</h3>
    <p><strong>Rule</strong>: If a task can't be broken into pieces under 4 hours, you don't understand it yet.</p>
    <pre><code>BAD:  &quot;Automate login flow&quot; (1 vague task)

GOOD: &quot;Automate login flow&quot;:
  â”œâ”€â”€ Analyze login page structure (2h)
  â”œâ”€â”€ Create LoginPage object (2h)
  â”œâ”€â”€ Implement valid login test (2h)
  â”œâ”€â”€ Handle invalid credentials (1h)
  â”œâ”€â”€ Handle locked account (1h)
  â”œâ”€â”€ Handle SSO redirect (4h)
  â”œâ”€â”€ Handle MFA flow (4h)
  â””â”€â”€ Create test data fixtures (2h)

TOTAL: 18h (not &quot;4 hours&quot;)
</code></pre>
    <h3 id="step-2-classify-by-complexity">Step 2: Classify by Complexity</h3>
    <table>
        <thead>
            <tr>
                <th>Complexity</th>
                <th>Examples</th>
                <th>Multiplier</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>SIMPLE</td>
                <td>Static content, standard forms</td>
                <td>1x</td>
            </tr>
            <tr>
                <td>MEDIUM</td>
                <td>Dynamic content, validation, modals</td>
                <td>2x</td>
            </tr>
            <tr>
                <td>COMPLEX</td>
                <td>Multi-step wizards, real-time updates, file handling</td>
                <td>4x</td>
            </tr>
        </tbody>
    </table>
    <h3 id="step-3-apply-base-estimates">Step 3: Apply Base Estimates</h3>
    <table>
        <thead>
            <tr>
                <th>Component</th>
                <th>Simple</th>
                <th>Medium</th>
                <th>Complex</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Page Object</td>
                <td>2h</td>
                <td>4h</td>
                <td>8h</td>
            </tr>
            <tr>
                <td>Form Field</td>
                <td>0.5h</td>
                <td>1h</td>
                <td>2h</td>
            </tr>
            <tr>
                <td>Table/Grid</td>
                <td>2h</td>
                <td>4h</td>
                <td>8h</td>
            </tr>
            <tr>
                <td>Modal/Dialog</td>
                <td>1h</td>
                <td>2h</td>
                <td>4h</td>
            </tr>
            <tr>
                <td>API Integration</td>
                <td>2h</td>
                <td>4h</td>
                <td>8h</td>
            </tr>
        </tbody>
    </table>
    <h3 id="step-4-add-multipliers">Step 4: Add Multipliers</h3>
    <pre><code>Environment factors:
  Ã— 1.5 for legacy system without data-testid attributes
  Ã— 1.3 for Shadow DOM heavy apps
  Ã— 1.5 for mobile/responsive testing
  Ã— 2.0 for first project in new technology

Team factors:
  Ã— 0.8 if team has done similar before
  Ã— 1.5 for new team members
  Ã— 1.2 for distributed teams
</code></pre>
    <h3 id="step-5-buffer-for-unknowns">Step 5: Buffer for Unknowns</h3>
    <pre><code>Confidence level â†’ Buffer:
  High confidence (done before):   +20%
  Medium confidence (similar):     +40%
  Low confidence (new territory):  +80%
</code></pre>
    <hr />
    <h1 id="chapter-21-sql-for-automation-testers">Chapter 21: SQL for Automation Testers</h1>
    <h2 id="why-sql-matters">Why SQL Matters</h2>
    <p>Automation often requires:
        - Verifying data persistence
        - Seeding test data
        - Cleaning up after tests
        - Diagnosing failures</p>
    <hr />
    <h2 id="common-optimization-patterns">Common Optimization Patterns</h2>
    <h3 id="anti-pattern-1-non-sargable-predicates">Anti-Pattern 1: Non-SARGable Predicates</h3>
    <pre><code class="language-sql">-- âŒ BAD: Function on column prevents index use
SELECT * FROM orders WHERE YEAR(created_at) = 2024;

-- âœ… GOOD: SARGable (Search ARGument ABLE)
SELECT * FROM orders 
WHERE created_at &gt;= '2024-01-01' 
  AND created_at &lt; '2025-01-01';
</code></pre>
    <h3 id="anti-pattern-2-select">Anti-Pattern 2: SELECT *</h3>
    <pre><code class="language-sql">-- âŒ BAD: Retrieves way more data than needed
SELECT * FROM users WHERE id = 123;

-- âœ… GOOD: Only needed columns
SELECT id, email, name FROM users WHERE id = 123;
</code></pre>
    <h3 id="index-strategy">Index Strategy</h3>
    <pre><code class="language-sql">-- For frequently queried columns:
CREATE INDEX idx_users_email ON users(email);

-- For composite queries:
CREATE INDEX idx_orders_user_date ON orders(user_id, created_at);
</code></pre>
    <hr />
    <h1 id="chapter-22-legacy-lessons-wisdom-from-uftqtp">Chapter 22: Legacy Lessons - Wisdom from UFT/QTP</h1>
    <h2 id="what-the-old-guard-got-right">What the Old Guard Got Right</h2>
    <p>Despite being "legacy," UFT/QTP established patterns still valuable today:</p>
    <h3 id="1-centralized-object-repository">1. Centralized Object Repository</h3>
    <pre><code class="language-python"># Modern implementation in Python
class ObjectRepository:
    class Amazon:
        class HomePage:
            SEARCH_BOX = (By.ID, &quot;twotabsearchtextbox&quot;)
            SEARCH_BUTTON = (By.ID, &quot;nav-search-submit-button&quot;)

        class ResultsPage:
            PRODUCT_LIST = (By.CSS_SELECTOR, &quot;div.s-result-item&quot;)
</code></pre>
    <h3 id="2-recovery-scenarios">2. Recovery Scenarios</h3>
    <pre><code class="language-python">from functools import wraps

def with_recovery(max_retries=3):
    def decorator(func):
        @wraps(func)
        def wrapper(self, *args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return func(self, *args, **kwargs)
                except UnexpectedAlertPresentException:
                    self.driver.switch_to.alert.dismiss()
                except StaleElementReferenceException:
                    time.sleep(0.5)
            raise Exception(f&quot;Failed after {max_retries} recovery attempts&quot;)
        return wrapper
    return decorator
</code></pre>
    <hr />
    <h1 id="chapter-23-ai-powered-testing">Chapter 23: AI-Powered Testing - The Future is Now</h1>
    <p style="text-align: center; margin: 2rem 0;">
        <img src="/book/images/ai.png" alt="AI Powered Testing"
            style="max-width: 100%; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);" />
    </p>
    <h2 id="the-ai-revolution-in-test-automation">The AI Revolution in Test Automation</h2>
    <p>Artificial Intelligence is fundamentally transforming how we approach test automation. From self-healing locators
        to intelligent test generation, AI is solving problems that seemed impossible just a few years ago.</p>

    <h3 id="why-ai-matters-for-testers">Why AI Matters for Testers</h3>
    <p>Traditional automation faces three persistent challenges:</p>
    <ul>
        <li><strong>Brittle Locators</strong> â€” A single UI change breaks dozens of tests</li>
        <li><strong>Maintenance Overhead</strong> â€” 40% of automation time goes to fixing existing tests</li>
        <li><strong>Limited Coverage</strong> â€” Manual creation of test scenarios misses edge cases</li>
    </ul>
    <p>AI addresses all three by introducing <strong>adaptive intelligence</strong> into the testing pipeline.</p>

    <hr />
    <h2 id="self-healing-locators">Self-Healing Locators with AI</h2>
    <p>When a locator fails, instead of failing the test immediately, AI can analyze the page and find the correct
        element automatically.</p>

    <h3 id="how-self-healing-works">ğŸ” Deep Dive: The Mechanics of Self-Healing</h3>
    <pre><code class="language-python">from selenium.webdriver.common.by import By
import openai

class SelfHealingLocator:
    def __init__(self, driver):
        self.driver = driver
        self.healing_cache = {}
    
    def find_element(self, locator, element_description):
        """
        Attempts to find element. If primary locator fails,
        uses AI to discover a new working selector.
        """
        try:
            return self.driver.find_element(*locator)
        except NoSuchElementException:
            return self._heal_and_find(locator, element_description)
    
    def _heal_and_find(self, failed_locator, description):
        # Get surrounding HTML context
        page_source = self.driver.page_source
        
        # Ask AI for alternative selector
        prompt = f"""
        The locator {failed_locator} failed to find the element.
        Element description: {description}
        
        Here is the page HTML (truncated):
        {page_source[:5000]}
        
        Suggest 3 alternative CSS selectors that would locate this element.
        Return only the selectors, one per line.
        """
        
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}]
        )
        
        # Try each suggested selector
        suggestions = response.choices[0].message.content.strip().split('\n')
        for selector in suggestions:
            try:
                element = self.driver.find_element(By.CSS_SELECTOR, selector.strip())
                self.healing_cache[failed_locator] = selector.strip()
                return element
            except:
                continue
        
        raise NoSuchElementException(f"Could not heal locator: {failed_locator}")
</code></pre>

    <h3 id="key-insight-ai-healing">ğŸ’¡ Key Insight: Healing Should Be Logged</h3>
    <p>Always log when AI heals a locator. This creates a backlog of locators that need human review, preventing silent
        technical debt accumulation.</p>

    <hr />
    <h2 id="ai-test-generation">AI-Powered Test Generation</h2>
    <p>Large Language Models can generate test cases from requirements, user stories, or even application code.</p>

    <h3 id="generating-tests-from-requirements">Generating Tests from Requirements</h3>
    <pre><code class="language-python">def generate_test_cases(user_story: str) -> list[dict]:
    """
    Uses AI to generate test scenarios from a user story.
    """
    prompt = f"""
    Given this user story:
    {user_story}
    
    Generate comprehensive test cases in the following JSON format:
    [
        {{
            "name": "test case name",
            "preconditions": ["list of setup steps"],
            "steps": ["step 1", "step 2"],
            "expected_result": "what should happen",
            "test_type": "positive|negative|edge_case"
        }}
    ]
    
    Include positive, negative, and edge cases.
    """
    
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.7
    )
    
    return json.loads(response.choices[0].message.content)

# Example usage
user_story = """
As a user, I want to reset my password via email,
so that I can regain access to my account if I forget my password.
Acceptance criteria:
- User enters email and clicks "Forgot Password"
- System sends reset link if email exists
- Link expires after 24 hours
- User can set new password (min 8 chars, 1 uppercase, 1 number)
"""

test_cases = generate_test_cases(user_story)
</code></pre>

    <hr />
    <h2 id="visual-ai-testing">Visual AI Testing</h2>
    <p>Traditional pixel-by-pixel comparison fails on dynamic content. AI-powered visual testing understands what
        <em>should</em> look different vs. what's a bug.
    </p>

    <h3 id="intelligent-visual-comparison">Intelligent Visual Comparison</h3>
    <table>
        <thead>
            <tr>
                <th>Traditional</th>
                <th>AI-Powered</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Fails on date/time changes</td>
                <td>Ignores dynamic content</td>
            </tr>
            <tr>
                <td>Fails on font rendering differences</td>
                <td>Understands "same enough"</td>
            </tr>
            <tr>
                <td>Many false positives</td>
                <td>Reports only real issues</td>
            </tr>
            <tr>
                <td>Requires exact match</td>
                <td>Uses semantic understanding</td>
            </tr>
        </tbody>
    </table>

    <hr />
    <h2 id="testing-llm-applications">Testing LLM Applications</h2>
    <p>When your application <em>uses</em> AI, testing becomes complex. How do you test non-deterministic outputs?</p>

    <h3 id="pytest-mockllm-approach">The Pytest-MockLLM Approach</h3>
    <p>Instead of calling real LLMs during tests (expensive, slow, non-deterministic), use recorded responses:</p>
    <pre><code class="language-python">import pytest
from pytest_mockllm import mock_openai

@pytest.fixture
def mock_llm():
    with mock_openai() as mock:
        mock.add_response(
            contains="summarize",
            response="This is a mock summary for testing purposes."
        )
        yield mock

def test_document_summarization(mock_llm):
    result = summarize_document("Long document text...")
    
    assert "mock summary" in result.lower()
    assert mock_llm.call_count == 1
</code></pre>

    <h3 id="testing-streaming-responses">Testing Streaming AI Responses</h3>
    <p>Chatbots stream responses token-by-token. Your tests need to handle this:</p>
    <pre><code class="language-python">from selenium_chatbot_test import ChatbotTester

def test_streaming_chatbot():
    tester = ChatbotTester(driver)
    
    # Send message and wait for complete response
    response = tester.send_and_wait(
        message="Explain Python decorators",
        timeout=30,
        stream_complete_marker="..."  # Indicates response finished
    )
    
    assert "function" in response.lower()
    assert len(response) > 100  # Substantial response
</code></pre>

    <hr />
    <h2 id="ai-tools-reference">AI Testing Tools Reference</h2>
    <table>
        <thead>
            <tr>
                <th>Tool</th>
                <th>Purpose</th>
                <th>When to Use</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Selector Scout</strong></td>
                <td>AI-powered locator generation</td>
                <td>Building new Page Objects</td>
            </tr>
            <tr>
                <td><strong>Pytest-MockLLM</strong></td>
                <td>Mock LLM responses in tests</td>
                <td>Testing AI-powered features</td>
            </tr>
            <tr>
                <td><strong>Selenium Chatbot Test</strong></td>
                <td>Test streaming AI interfaces</td>
                <td>Chatbot/assistant testing</td>
            </tr>
            <tr>
                <td><strong>Applitools</strong></td>
                <td>Visual AI testing</td>
                <td>UI regression detection</td>
            </tr>
            <tr>
                <td><strong>Testim</strong></td>
                <td>Self-healing automation</td>
                <td>Enterprise-scale web testing</td>
            </tr>
        </tbody>
    </table>

    <hr />
    <h2 id="ai-testing-best-practices">ğŸ“‹ AI Testing Best Practices</h2>
    <ol>
        <li><strong>Human Oversight</strong> â€” Never let AI make decisions without logging for review</li>
        <li><strong>Fallback Mechanisms</strong> â€” Always have traditional logic as backup</li>
        <li><strong>Cost Monitoring</strong> â€” API calls add up; cache aggressively</li>
        <li><strong>Version Pinning</strong> â€” LLM behavior changes; pin model versions</li>
        <li><strong>Confidence Thresholds</strong> â€” Reject AI suggestions below a confidence score</li>
    </ol>

    <blockquote>
        <p><em>"AI doesn't replace testersâ€”it makes good testers exceptional and eliminates the tedious parts of the
                job."</em></p>
    </blockquote>

    <hr />
    <h1 id="appendices">APPENDICES</h1>
    <hr />
    <h2 id="appendix-a-tool-installation-quick-reference">Appendix A: The Complete Toolkit</h2>
    <p>Every project in this book is open-source and available:</p>
    <table>
        <thead>
            <tr>
                <th>Tool</th>
                <th>Problem</th>
                <th>GitHub</th>
                <th>PyPI</th>
                <th>Blog</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Waitless</td>
                <td>Flaky tests</td>
                <td><a href="https://github.com/godhiraj-code/waitless"
                        target="_blank">github.com/godhiraj-code/waitless</a></td>
                <td><a href="https://pypi.org/project/waitless/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/waitless-zero-flake-automation" target="_blank">Blog</a>
                </td>
            </tr>
            <tr>
                <td>Visual Guard</td>
                <td>Visual regression</td>
                <td><a href="https://github.com/godhiraj-code/visual-guard"
                        target="_blank">github.com/godhiraj-code/visual-guard</a></td>
                <td><a href="https://pypi.org/project/visual-guard/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/visual-guard-pixel-perfect-testing" target="_blank">Blog</a>
                </td>
            </tr>
            <tr>
                <td>Selenium Teleport</td>
                <td>Slow authentication</td>
                <td><a href="https://github.com/godhiraj-code/selenium-teleport"
                        target="_blank">github.com/godhiraj-code/selenium-teleport</a></td>
                <td><a href="https://pypi.org/project/selenium-teleport/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/faster-test-automation-with-selenium-teleport"
                        target="_blank">Blog</a></td>
            </tr>
            <tr>
                <td>StealthAutomation</td>
                <td>Bot detection</td>
                <td><a href="https://github.com/godhiraj-code/stealthautomation"
                        target="_blank">github.com/godhiraj-code/stealthautomation</a></td>
                <td><a href="https://pypi.org/project/stealthautomation/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/stealth-automation-bypassing-anti-bot-systems"
                        target="_blank">Blog</a></td>
            </tr>
            <tr>
                <td>Lumos ShadowDOM</td>
                <td>Shadow DOM traversal</td>
                <td><a href="https://github.com/godhiraj-code/lumos-shadowdom"
                        target="_blank">github.com/godhiraj-code/lumos-shadowdom</a></td>
                <td><a href="https://pypi.org/project/lumos-shadowdom/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/mastering-shadow-dom-automation" target="_blank">Blog</a>
                </td>
            </tr>
            <tr>
                <td>Chatbot Test</td>
                <td>AI chatbot testing</td>
                <td><a href="https://github.com/godhiraj-code/selenium-chatbot-test"
                        target="_blank">github.com/godhiraj-code/selenium-chatbot-test</a></td>
                <td><a href="https://pypi.org/project/selenium-chatbot-test/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/testing-ai-chatbots-with-selenium" target="_blank">Blog</a>
                </td>
            </tr>
            <tr>
                <td>pytest-mockllm</td>
                <td>LLM testing</td>
                <td><a href="https://github.com/godhiraj-code/pytest-mockllm"
                        target="_blank">github.com/godhiraj-code/pytest-mockllm</a></td>
                <td><a href="https://pypi.org/project/pytest-mockllm/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/pytest-mockllm-zero-cost-llm-testing"
                        target="_blank">Blog</a></td>
            </tr>
            <tr>
                <td>Visual Sonar</td>
                <td>Remote desktop & VDI automation</td>
                <td><a href="https://github.com/godhiraj-code/visual-sonar"
                        target="_blank">github.com/godhiraj-code/visual-sonar</a></td>
                <td><a href="https://pypi.org/project/visual-sonar/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/visual-sonar-when-all-you-have-are-pixels"
                        target="_blank">Blog</a></td>
            </tr>
            <tr>
                <td>pytest-glow-report</td>
                <td>Enterprise reporting</td>
                <td><a href="https://github.com/godhiraj-code/pytest-glow-report"
                        target="_blank">github.com/godhiraj-code/pytest-glow-report</a></td>
                <td><a href="https://pypi.org/project/pytest-glow-report/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/beautiful-pytest-reports" target="_blank">Blog</a></td>
            </tr>
            <tr>
                <td>Project Vandal</td>
                <td>UI mutation testing</td>
                <td><a href="https://github.com/godhiraj-code/vandal"
                        target="_blank">github.com/godhiraj-code/vandal</a></td>
                <td><a href="https://pypi.org/project/vandal-testing/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/project-vandal-ui-mutation-testing" target="_blank">Blog</a>
                </td>
            </tr>
        </tbody>
    </table>
    <hr />
    <h2 id="appendix-b-common-exception-reference">Appendix B: Common Exception Reference</h2>
    <table>
        <thead>
            <tr>
                <th>Exception</th>
                <th>Cause</th>
                <th>Solution</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>NoSuchElementException</code></td>
                <td>Element not in DOM</td>
                <td>Wait for presence, check selector</td>
            </tr>
            <tr>
                <td><code>ElementNotInteractableException</code></td>
                <td>Element exists but can't be interacted with</td>
                <td>Wait for clickable, check visibility</td>
            </tr>
            <tr>
                <td><code>StaleElementReferenceException</code></td>
                <td>Element was removed/re-added to DOM</td>
                <td>Re-find element, use Waitless</td>
            </tr>
            <tr>
                <td><code>TimeoutException</code></td>
                <td>Wait condition not met in time</td>
                <td>Increase timeout, check condition</td>
            </tr>
            <tr>
                <td><code>WebDriverException</code></td>
                <td>Browser/driver communication issue</td>
                <td>Restart browser, check versions</td>
            </tr>
            <tr>
                <td><code>ElementClickInterceptedException</code></td>
                <td>Another element covering target</td>
                <td>Scroll to view, wait for overlays</td>
            </tr>
        </tbody>
    </table>
    <hr />
    <h2 id="appendix-c-glossary">Appendix C: Glossary</h2>
    <table>
        <thead>
            <tr>
                <th>Term</th>
                <th>Definition</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>DOM</strong></td>
                <td>Document Object Model - tree structure of HTML elements</td>
            </tr>
            <tr>
                <td><strong>Shadow DOM</strong></td>
                <td>Encapsulated DOM tree hidden from main document</td>
            </tr>
            <tr>
                <td><strong>Light DOM</strong></td>
                <td>Regular DOM, visible to querySelector</td>
            </tr>
            <tr>
                <td><strong>WebDriver</strong></td>
                <td>W3C protocol for browser automation</td>
            </tr>
            <tr>
                <td><strong>CDP</strong></td>
                <td>Chrome DevTools Protocol - direct browser control</td>
            </tr>
            <tr>
                <td><strong>Flakiness</strong></td>
                <td>Tests that intermittently pass/fail without code changes</td>
            </tr>
            <tr>
                <td><strong>SSIM</strong></td>
                <td>Structural Similarity Index - perceptual image comparison</td>
            </tr>
            <tr>
                <td><strong>pHash</strong></td>
                <td>Perceptual Hash - image fingerprinting algorithm</td>
            </tr>
            <tr>
                <td><strong>SARGable</strong></td>
                <td>Search ARGument-able - query can use indexes</td>
            </tr>
            <tr>
                <td><strong>Mutation Testing</strong></td>
                <td>Introducing bugs to verify test coverage</td>
            </tr>
            <tr>
                <td><strong>TTFT</strong></td>
                <td>Time to First Token - latency metric for streaming</td>
            </tr>
        </tbody>
    </table>
    <hr />
    <h1 id="conclusion">Conclusion</h1>
    <h2 id="the-modern-automation-engineers-manifesto">The Modern Automation Engineer's Manifesto</h2>
    <p>After 10+ years of building, breaking, and rebuilding automation frameworks, these truths have emerged:</p>
    <h3 id="truth-1-flakiness-is-a-design-problem-not-a-fate">Truth 1: Flakiness Is a Design Problem, Not a Fate</h3>
    <p>Every flaky test has a root cause. The tools in this bookâ€”Waitless, intelligent waits, stability detectionâ€”exist
        because understanding those causes leads to solutions.</p>
    <h3 id="truth-2-the-browser-is-an-adversary-to-be-tamed">Truth 2: The Browser Is an Adversary to Be Tamed</h3>
    <p>Browsers weren't designed for automation. They load asynchronously, animate without notice, and guard their
        shadows. Success comes from instrumenting the browser itself, not fighting its nature.</p>
    <h3 id="truth-3-speed-without-reliability-is-waste">Truth 3: Speed Without Reliability Is Waste</h3>
    <p>A fast, flaky test suite is worse than no suite at all. It generates false signals, wastes developer time, and
        erodes trust. Build stability first, then optimize for speed.</p>
    <h3 id="truth-4-the-best-test-is-the-one-that-catches-bugs">Truth 4: The Best Test Is the One That Catches Bugs</h3>
    <p>Automation isn't about coverage percentages or green dashboards. It's about catching defects before they reach
        users. Every test should have a clear purpose: what bug would it catch?</p>
    <h3 id="truth-5-invest-in-tooling">Truth 5: Invest in Tooling</h3>
    <p>Hours spent building reusable tools save days of repetitive work. The projects in this book exist because solving
        problems once, properly, beats solving them poorly forever.</p>
    <hr />
    <h2 id="the-complete-toolkit">The Complete Toolkit</h2>
    <p>Every project in this book is open-source and available:</p>
    <table>
        <thead>
            <tr>
                <th>Tool</th>
                <th>Problem</th>
                <th>GitHub</th>
                <th>PyPI</th>
                <th>Blog</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Waitless</td>
                <td>Flaky tests</td>
                <td><a href="https://github.com/godhiraj-code/waitless"
                        target="_blank">github.com/godhiraj-code/waitless</a></td>
                <td><a href="https://pypi.org/project/waitless/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/waitless-zero-flake-automation" target="_blank">Blog</a>
                </td>
            </tr>
            <tr>
                <td>Visual Guard</td>
                <td>Visual regression</td>
                <td><a href="https://github.com/godhiraj-code/visual-guard"
                        target="_blank">github.com/godhiraj-code/visual-guard</a></td>
                <td><a href="https://pypi.org/project/visual-guard/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/visual-guard-pixel-perfect-testing" target="_blank">Blog</a>
                </td>
            </tr>
            <tr>
                <td>Selenium Teleport</td>
                <td>Slow authentication</td>
                <td><a href="https://github.com/godhiraj-code/selenium-teleport"
                        target="_blank">github.com/godhiraj-code/selenium-teleport</a></td>
                <td><a href="https://pypi.org/project/selenium-teleport/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/faster-test-automation-with-selenium-teleport"
                        target="_blank">Blog</a></td>
            </tr>
            <tr>
                <td>StealthAutomation</td>
                <td>Bot detection</td>
                <td><a href="https://github.com/godhiraj-code/stealthautomation"
                        target="_blank">github.com/godhiraj-code/stealthautomation</a></td>
                <td><a href="https://pypi.org/project/stealthautomation/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/stealth-automation-bypassing-anti-bot-systems"
                        target="_blank">Blog</a></td>
            </tr>
            <tr>
                <td>Lumos ShadowDOM</td>
                <td>Shadow DOM traversal</td>
                <td><a href="https://github.com/godhiraj-code/lumos-shadowdom"
                        target="_blank">github.com/godhiraj-code/lumos-shadowdom</a></td>
                <td><a href="https://pypi.org/project/lumos-shadowdom/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/lumos-shadowdom-selenium-shadow-dom"
                        target="_blank">Blog</a></td>
            </tr>
            <tr>
                <td>Chatbot Test</td>
                <td>AI chatbot testing</td>
                <td><a href="https://github.com/godhiraj-code/selenium-chatbot-test"
                        target="_blank">github.com/godhiraj-code/selenium-chatbot-test</a></td>
                <td><a href="https://pypi.org/project/selenium-chatbot-test/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/selenium-chatbot-test-automating-llm-chat"
                        target="_blank">Blog</a></td>
            </tr>
            <tr>
                <td>pytest-mockllm</td>
                <td>LLM testing</td>
                <td><a href="https://github.com/godhiraj-code/pytest-mockllm"
                        target="_blank">github.com/godhiraj-code/pytest-mockllm</a></td>
                <td><a href="https://pypi.org/project/pytest-mockllm/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/pytest-mockllm-zero-cost-llm-testing"
                        target="_blank">Blog</a></td>
            </tr>
            <tr>
                <td>Visual Sonar</td>
                <td>Remote desktop & VDI automation</td>
                <td><a href="https://github.com/godhiraj-code/visual-sonar"
                        target="_blank">github.com/godhiraj-code/visual-sonar</a></td>
                <td><a href="https://pypi.org/project/visual-sonar/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/visual-sonar-when-all-you-have-are-pixels"
                        target="_blank">Blog</a></td>
            </tr>
            <tr>
                <td>pytest-glow-report</td>
                <td>Enterprise reporting</td>
                <td><a href="https://github.com/godhiraj-code/pytest-glow-report"
                        target="_blank">github.com/godhiraj-code/pytest-glow-report</a></td>
                <td><a href="https://pypi.org/project/pytest-glow-report/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/pytest-glow-report-beautiful-html-reports"
                        target="_blank">Blog</a></td>
            </tr>
            <tr>
                <td>Project Vandal</td>
                <td>UI mutation testing</td>
                <td><a href="https://github.com/godhiraj-code/vandal"
                        target="_blank">github.com/godhiraj-code/vandal</a></td>
                <td><a href="https://pypi.org/project/vandal-testing/" target="_blank">PyPI</a></td>
                <td><a href="https://www.dhirajdas.com/blog/project-vandal-ui-mutation-testing" target="_blank">Blog</a>
                </td>
            </tr>
        </tbody>
    </table>
    <hr />
    <p><em>Â© 2025 Dhiraj Das. All rights reserved.</em></p>
</body>

</html>